// Generate xf asymmetries
#include <TROOT.h>
#include <TStyle.h>
#include <TFile.h>
#include <TTree.h>
#include <TH1.h>
#include <TH2.h>
#include <TF1.h>
#include <TLegend.h>
#include <TLine.h>
#include <TLatex.h>
#include <TCanvas.h>
#include <iostream>

#include <stdio.h>

using namespace std;

#include <my_root_functions.C>
#include <asym_funcs.C>

void asym2(const int Trig = 1, const int NBins = 1, const int Peak = 0, const int Bkgnd = 0, const int RMIN = 11, const int RMAX = 19, const int Fill = 0, const int Train = 67, const int Final = 1)
{
  
  //gROOT -> ProcessLine ("~/root/init.C");
  gROOT -> ProcessLine (".L ./my_root_functions.C");
  gROOT -> ProcessLine (".L ./asym_funcs.C");
  gROOT -> ProcessLine (".L ./fit_funcs.C");
  gROOT -> SetStyle("Plain");
  gStyle -> SetPalette (1);
  //gStyle -> SetOptTitle(0);
  gStyle -> SetOptStat(0);
  gStyle -> SetOptFit(1);
  gStyle -> SetCanvasColor(0);
  Float_t PI = 3.141592654;
  //File input/output names
  char inName[64];
  char outName[64];
  char inArm[5];
  char inTrig[5];
  char inBeam[7];
  char inPol[5];
  if(Trig == 0) sprintf (inTrig, "Low");
  if(Trig == 1) sprintf (inTrig, "High");
  else if(Trig == 2) sprintf (inTrig, "Sim");

  //Beam polarization
  Double_t bluePol = .9;
  Double_t bluePolError = 0.02;
  Double_t yellowPol = 0.9;
  Double_t yellowPolError = 0.02;
  char Beam[6];
  char Poldir[5];
  char LRdir[6];

  TRandom *YRand = new TRandom3(0);
  TRandom *BRand = new TRandom3(0);

  //ok, lets make our histograms!
  const Int_t nbins = NBins;//2 for mb, 4 for trig
  Float_t binjump = 2.5;
  if(Trig == 1){binjump = 3.5;}
  Int_t mbins = 140;
  Double_t mmin = 0.;
  Double_t mmax = 14;
  const Int_t phibins = 8;
  const Int_t cosbins = 32;
  Double_t phimin = -PI;
  Double_t phimax = +PI;
  char Hname[128];

  //Yield histograms
  TH2F *Yield[2][nbins][2][2]; // [arm][xf][beam][pol]
  TH2F *Yieldmix[2][nbins];
  TH2F *Yield2[2][nbins][2][2]; // [arm][xf][beam][pol]
  TH2F *Yieldmix2[2][nbins];
  TH2F *Yield3[2][nbins]; // [arm][xf]
  TH2F *Yieldmix3[2][nbins];
  TH1D *Hmass[2][nbins];
  for (int a = 0; a < 2; a++)
    for (int k = 0; k < nbins; k++){
      for (int i = 0; i < 2; i++)
	for (int j = 0; j < 2; j++){
	  sprintf (Hname, "Yield_arm%d_xf%d_b%dy%d", a, k, i, j);
	  Yield[a][k][i][j] = new TH2F (Hname, Hname, mbins, mmin, mmax, phibins, phimin, phimax);
	  sprintf (Hname, "Yield2_arm%d_xf%d_b%dy%d", a, k, i, j);
	  Yield2[a][k][i][j] = new TH2F (Hname, Hname, mbins, mmin, mmax, 2, phimin, phimax);
	}
      sprintf (Hname, "Yieldmix_arm%d_xf%d", a, k);
      Yieldmix[a][k] = new TH2F (Hname, Hname, mbins, mmin, mmax, phibins, phimin, phimax);
      sprintf (Hname, "Yieldmix2_arm%d_xf%d", a, k);
      Yieldmix2[a][k] = new TH2F (Hname, Hname, mbins, mmin, mmax, 2, phimin, phimax);
      sprintf (Hname, "Yield3_arm%d_xf%d", a, k);
      Yield3[a][k] = new TH2F (Hname, Hname, mbins, mmin, mmax, cosbins, phimin, phimax);
      sprintf (Hname, "Yieldmix3_arm%d_xf%d", a, k);
      Yieldmix3[a][k] = new TH2F (Hname, Hname, mbins, mmin, mmax, cosbins, phimin, phimax);
      sprintf (Hname, "Hmass_arm%d_xf%d", a, k);
      Hmass[a][k] = new TH1D (Hname, Hname, mbins, mmin, mmax);
    }

  // Fit mass spectra summed over phi !!!
  //declare fits
  TF1 *drawboth[nbins][phibins][2][2];
  TF1 *drawgamma[phibins][2][2];
  TF1 *drawgaus[phibins][2][2];
  TF1 *drawboth2[nbins][2][2][2];
  TF1 *drawgamma2[2][2][2];
  TF1 *drawgaus2[2][2][2];
  TF1 *drawboth3[nbins][2]; //[arm][xf]
  TF1 *drawgamma3;
  TF1 *drawgaus3;
  float drawstart;
  //if(Trig == 1) drawstart = 0.35;
  //float drawstart[nbins];
  //if(Trig == 0) {drawstart[nbins] = {0.25, 0.25}};
  //if(Trig == 1) {drawstart[nbins] = {0.3, 0.35, 0.35}};
  for (int p = 0; p < phibins; p++)
    for (int i = 0; i < 2; i++)
      for (int j = 0; j < 2; j++){
	for (int k = 0; k < nbins; k++){
	  //drawstart = 0.25 + float(Trig) * 0.05 + float(Trig) * float(k) * 0.05;
	  drawstart = 0.25;
	  sprintf(Hname, "drawboth_xf%d_%d_%d_%d", k, p, i, j);
	  if(k > -1){drawboth[k][p][i][j] = new TF1(Hname, "[0]*TMath::GammaDist(x,[1],[2],[3]) + gaus(4) + gaus(7) + [10]", drawstart, 0.9);}
	  //else{drawboth[k][p][i][j] = new TF1(Hname, "[0]*TMath::GammaDist(x,[1],[2],[3]) + gaus(4)", drawstart, 0.9);}
	  drawboth[k][p][i][j] -> SetParLimits(0, 1, 1000000); 
	  drawboth[k][p][i][j] -> SetParLimits(4, 0, 1000000); 
	  drawboth[k][p][i][j] -> SetParLimits(7, 0, 1000000); 
	  drawboth[k][p][i][j] -> SetParLimits(1, 1.01, 5.5);
	  drawboth[k][p][i][j] -> SetParLimits(2, 0.02, 0.35);
	  drawboth[k][p][i][j] -> SetParLimits(3, 0.01, 0.15);
	  drawboth[k][p][i][j] -> SetParLimits(5, 0.53, 0.58);
	  drawboth[k][p][i][j] -> SetParLimits(6, 0.02, 0.06);
	  drawboth[k][p][i][j] -> SetParLimits(8, 0.7, 0.83);
	  drawboth[k][p][i][j] -> SetParLimits(9, 0.02, 0.13);
	}
	sprintf(Hname, "drawgamma_xf%d_%d_%d", p, i, j);
	drawgamma[p][i][j] = new TF1(Hname, "[0]*TMath::GammaDist(x,[1],[2],[3]) + gaus(4) + [7]", 0.35, 0.85);
	drawgamma[p][i][j] -> SetLineColor(2);
	sprintf(Hname, "drawgaus_xf%d_%d_%d", p, i, j);
	drawgaus[p][i][j] = new TF1(Hname, "gaus", .45, .64);
	drawgaus[p][i][j] -> SetLineColor(8);
      }

  for (int p = 0; p < 2; p++)
    for (int i = 0; i < 2; i++)
      for (int j = 0; j < 2; j++){
	for (int k = 0; k < nbins; k++){
	  drawstart = 0.25 + float(Trig) * 0.05 + float(Trig) * float(k) * 0.05;
	  //drawstart = 0.25;
	  sprintf(Hname, "drawboth2_xf%d_%d_%d_%d", k, p, i, j);
	  drawboth2[k][p][i][j] = new TF1(Hname, "[0]*TMath::GammaDist(x,[1],[2],[3]) + gaus(4) + gaus(7) + [10]", drawstart, 0.9);
	  //else{drawboth2[k][p][i][j] = new TF1(Hname, "[0]*TMath::GammaDist(x,[1],[2],[3]) + gaus(4)", drawstart, 0.9);}

	  drawboth2[k][p][i][j] -> SetParLimits(0, 1, 1000000); 
	  drawboth2[k][p][i][j] -> SetParLimits(4, 0, 1000000); 
	  drawboth2[k][p][i][j] -> SetParLimits(7, 0, 1000000); 
	  drawboth2[k][p][i][j] -> SetParLimits(1, 1.01, 5.5);
	  drawboth2[k][p][i][j] -> SetParLimits(2, 0.02, 0.35);
	  drawboth2[k][p][i][j] -> SetParLimits(3, 0.01, 0.15);
	  drawboth2[k][p][i][j] -> SetParLimits(5, 0.53, 0.58);
	  drawboth2[k][p][i][j] -> SetParLimits(6, 0.02, 0.06);
	  drawboth2[k][p][i][j] -> SetParLimits(8, 0.7, 0.83);
	  drawboth2[k][p][i][j] -> SetParLimits(9, 0.02, 0.13);
	}
	sprintf(Hname, "drawgamma2_xf%d_%d_%d", p, i, j);
	drawgamma2[p][i][j] = new TF1(Hname, "[0]*TMath::GammaDist(x,[1],[2],[3]) + gaus(4) + [7]", 0.35, 0.85);
	drawgamma2[p][i][j] -> SetLineColor(2);
	sprintf(Hname, "drawgaus2_xf%d_%d_%d", p, i, j);
	drawgaus2[p][i][j]= new TF1(Hname, "gaus", .45, .64);
	drawgaus2[p][i][j] -> SetLineColor(8);
      }
  for (int a = 0; a < 2; a++)
    for (int k = 0; k < nbins; k++){
      //drawstart = 0.25 + float(Trig) * 0.05 + float(Trig) * float(k) * 0.05; 
      drawstart = 0.25;
      sprintf(Hname, "drawboth3_arm%d_xf%d", a, k);
      drawboth3[a][k] = new TF1(Hname, "[0]*TMath::GammaDist(x,[1],[2],[3]) + gaus(4) + gaus(7) + [10]", drawstart, 0.9); 
      if (Trig == 0 || Trig == 2){drawboth3[a][k] -> SetParameters(30 , 1.60, 0.22, 0.15, 402 , .55, .03, 0);}
      if (Trig == 1){drawboth3[a][k] -> SetParameters(146, 2.24, 0.18, 0.08, 1000, .55, .03, 80, .78, 0.05, 100);}
      drawboth3[a][k] -> SetParLimits(0, 1, 1000000); 
      drawboth3[a][k] -> SetParLimits(4, 0, 1000000); 
      drawboth3[a][k] -> SetParLimits(7, 0, 1000000); 
      if(Trig == 1){
	//if(k < 3)drawboth3[a][k] -> SetParLimits(1, 1.001, 15);
	drawboth3[a][k] -> SetParLimits(1, 1.001, 5.5);
	drawboth3[a][k] -> SetParLimits(2, 0.0, 0.35);
	drawboth3[a][k] -> SetParLimits(3, 0.01, 0.15);
      }
      drawboth3[a][k] -> SetParLimits(5, 0.53, 0.58);
      drawboth3[a][k] -> SetParLimits(6, 0.02, 0.06);
      drawboth3[a][k] -> SetParLimits(8, 0.7, 0.83);
      drawboth3[a][k] -> SetParLimits(9, 0.02, 0.13);
      if(Bkgnd == 1)drawboth3[a][k] -> SetParLimits(10, 0, 1);
    }
  drawgamma3 = new TF1("drawgamma3", "[0]*TMath::GammaDist(x,[1],[2],[3]) + gaus(4) + [7]", 0.35, 0.85);
  drawgamma3 -> SetLineColor(2);
  drawgaus3= new TF1("drawgaus3", "gaus", .45, .64);
  drawgaus3 -> SetLineColor(8);

  TF1 *fitmass  = new TF1 ("gaus", "gaus", 0.53, 0.61);
  fitmass -> SetParLimits(1, 0.53, 0.58);
  fitmass -> SetParLimits(2, 0.02, 0.05);
  Float_t ratio_min = .8;
  Float_t ratio_max = 1.1;
 Float_t ratio_min2 = 0.3;
  Float_t ratio_max2 = 0.85;
  if(Trig == 1){
    ratio_min = 1.0;
    ratio_max = 1.3;
    //ratio_min2 = 0.6;
    //ratio_max2 = 0.85;
  }
  TF1 *fitratio = new TF1 ("pol0", "pol0", ratio_min, ratio_max);
  TF1 *fitratio2 = new TF1 ("pol0", "pol0", ratio_min2, ratio_max2);
  TF1 *fitgaus = new TF1 ("gaus", "gaus", 0.52, 0.58);
  
  //mixed event subtraction histograms
  TH1D *tmass;
  TH1D *tmass2;
  TH1D *tmass3;
  TH1D *hmixmass = new TH1D ("mixmass", "mixmass", mbins, mmin, mmax); hmixmass -> SetLineColor (2);
  TH1D *hmixmass2 = new TH1D ("mixmass2", "mixmass2", mbins, mmin, mmax); hmixmass2 -> SetLineColor (2);
  TH1D *hmixmass3 = new TH1D ("mixmass3", "mixmass3", mbins, mmin, mmax); hmixmass3 -> SetLineColor (2);
  TH1D *hmass[phibins][2][2];
  TH1D *hmass_ratio[phibins][2][2];
  TH1D *hmix_norm[phibins][2][2];
  TH1D *hmass_sub[phibins][2][2];
  TH1D *hmass_final[phibins][2][2];
  double mixnorm[phibins][2][2];
  TH1D *hmass2[2][2][2];
  TH1D *hmass_ratio2[2][2][2];
  TH1D *hmix_norm2[2][2][2];
  TH1D *hmass_sub2[2][2][2];
  TH1D *hmass_final2[2][2][2];
  double mixnorm2[2][2][2];
  TH1D *hmass3;
  TH1D *hmass_ratio3;
  TH1D *hmix_norm3;
  TH1D *hmass_sub3;
  TH1D *hmass_final3;
  double mixnorm3;

  //mean xf, pt, eta histos
  TH2F *yxfmass  = new TH2F ("yxfmass",  "yxfmass",  100, 0., 1., 100, 0., 1. );
  TH2F *yxfmass3  = new TH2F ("yxfmass3",  "yxfmass3",  100, 0., 1., 100, 0., 1. );
  TH1F *yeta  = new TH1F ("yeta",  "yeta", 300, 2.0, 5.0 );
  TH3F *ymasspt  = new TH3F ("yxfmasspt",  "yxfmasspt",  100, 0., 1., 100, 0., 1., 500, 0., 5. );
  TH3F *yxfmasspt3  = new TH3F ("yxfmasspt3",  "yxfmasspt3",  100, 0., 1., 100, 0., 1., 500, 0., 5. );
  TH3F *ymasseta  = new TH3F ("yxfmasseta",  "yxfmasseta",  100, 0., 1., 100, 0., 1., 300, 2., 5. );
  TH3F *yxfmasseta3  = new TH3F ("yxfmasseta3",  "yxfmasseta3",  100, 0., 1., 100, 0., 1., 300, 2., 5. );
  TH1F *xf_mean = new TH1F("xf_mean","xf_mean",10, 0., 1.);
  TH1F *pt_mean = new TH1F("pt_mean","pt_mean",10, 0., 1.);
  TH1F *eta_mean = new TH1F("eta_mean","eta_mean",10, 0., 1.);
  TH1D *txf3;
  TH1D *tpt3;
  TH1D *teta3;
  
  for (int p = 0; p < phibins; p++)
    for (int i = 0; i < 2; i++)
      for (int j = 0; j < 2; j++){
	sprintf (Hname, "mass_%d_%d_%d", p, i, j);
	hmass[p][i][j] = new TH1D (Hname, Hname, mbins, mmin, mmax);
	hmass[p][i][j] -> GetXaxis() -> SetTitle ("m_{#gamma#gamma} (GeV/c^{2})");
	hmass[p][i][j] -> SetLineColor (1);
	hmass[p][i][j] -> Sumw2();

	sprintf (Hname, "mass_ratio_%d_%d_%d", p, i, j);
	hmass_ratio[p][i][j] = new TH1D (Hname, Hname, mbins, mmin, mmax);
	hmass_ratio[p][i][j] -> GetXaxis() -> SetTitle ("m_{#gamma#gamma} (GeV/c^{2})");
	hmass_ratio[p][i][j] -> SetLineColor (3);
	hmass_ratio[p][i][j] -> Sumw2();

	sprintf (Hname, "mix_norm_%d_%d_%d", p, i, j);
	hmix_norm[p][i][j] = new TH1D (Hname, Hname, mbins, mmin, mmax);
	hmix_norm[p][i][j] -> GetXaxis() -> SetTitle ("m_{#gamma#gamma} (GeV/c^{2})");
	hmix_norm[p][i][j] -> SetLineColor (2);
	hmix_norm[p][i][j] -> Sumw2();

	sprintf (Hname, "mass_sub_%d_%d_%d", p, i, j);
	hmass_sub[p][i][j] = new TH1D (Hname, Hname, mbins, mmin, mmax);
	hmass_sub[p][i][j] -> GetXaxis() -> SetTitle ("m_{#gamma#gamma} (GeV/c^{2})");
	hmass_sub[p][i][j] -> SetLineColor (4);
	hmass_sub[p][i][j] -> Sumw2();

	sprintf (Hname, "mass_final_%d_%d_%d", p, i, j);
	hmass_final[p][i][j] = new TH1D (Hname, Hname, mbins, mmin, mmax);
	hmass_final[p][i][j] -> GetXaxis() -> SetTitle ("m_{#gamma#gamma} (GeV/c^{2})");
	hmass_final[p][i][j] -> SetLineColor (4);
	hmass_final[p][i][j] -> Sumw2();
      }
  for (int p = 0; p < 2; p++)
    for (int i = 0; i < 2; i++)
      for (int j = 0; j < 2; j++){
	sprintf (Hname, "mass2_%d_%d_%d", p, i, j);
	hmass2[p][i][j] = new TH1D (Hname, Hname, mbins, mmin, mmax);
	hmass2[p][i][j] -> GetXaxis() -> SetTitle ("m_{#gamma#gamma} (GeV/c^{2})");
	hmass2[p][i][j] -> SetLineColor (1);
	hmass2[p][i][j] -> Sumw2();

	sprintf (Hname, "mass_ratio2_%d_%d_%d", p, i, j);
	hmass_ratio2[p][i][j] = new TH1D (Hname, Hname, mbins, mmin, mmax);
	hmass_ratio2[p][i][j] -> GetXaxis() -> SetTitle ("m_{#gamma#gamma} (GeV/c^{2})");
	hmass_ratio2[p][i][j] -> SetLineColor (4);
	hmass_ratio2[p][i][j] -> Sumw2();

	sprintf (Hname, "mix_norm2_%d_%d_%d", p, i, j);
	hmix_norm2[p][i][j] = new TH1D (Hname, Hname, mbins, mmin, mmax);
	hmix_norm2[p][i][j] -> GetXaxis() -> SetTitle ("m_{#gamma#gamma} (GeV/c^{2})");
	hmix_norm2[p][i][j] -> SetLineColor (2);
	hmix_norm2[p][i][j] -> Sumw2();

	sprintf (Hname, "mass_sub2_%d_%d_%d", p, i, j);
	hmass_sub2[p][i][j] = new TH1D (Hname, Hname, mbins, mmin, mmax);
	hmass_sub2[p][i][j] -> GetXaxis() -> SetTitle ("m_{#gamma#gamma} (GeV/c^{2})");
	hmass_sub2[p][i][j] -> SetLineColor (4);
	hmass_sub2[p][i][j] -> Sumw2();

	sprintf (Hname, "mass_final2_%d_%d_%d", p, i, j);
	hmass_final2[p][i][j] = new TH1D (Hname, Hname, mbins, mmin, mmax);
	hmass_final2[p][i][j] -> GetXaxis() -> SetTitle ("m_{#gamma#gamma} (GeV/c^{2})");
	hmass_final2[p][i][j] -> SetLineColor (4);
	hmass_final2[p][i][j] -> Sumw2();
      }

  sprintf (Hname, "mass3");
  hmass3 = new TH1D (Hname, Hname, mbins, mmin, mmax);
  hmass3 -> GetXaxis() -> SetTitle ("m_{#gamma#gamma} (GeV/c^{2})");
  hmass3 -> SetLineColor (1);
  hmass3 -> Sumw2();
  
  sprintf (Hname, "mass_ratio3");
  hmass_ratio3 = new TH1D (Hname, Hname, mbins, mmin, mmax);
  hmass_ratio3 -> GetXaxis() -> SetTitle ("m_{#gamma#gamma} (GeV/c^{2})");
  hmass_ratio3 -> SetLineColor (4);
  hmass_ratio3 -> Sumw2();
  
  sprintf (Hname, "mix_norm3");
  hmix_norm3 = new TH1D (Hname, Hname, mbins, mmin, mmax);
  hmix_norm3 -> GetXaxis() -> SetTitle ("m_{#gamma#gamma} (GeV/c^{2})");
  hmix_norm3 -> SetLineColor (2);
  hmix_norm3 -> Sumw2();
  
  sprintf (Hname, "mass_sub3");
  hmass_sub3 = new TH1D (Hname, Hname, mbins, mmin, mmax);
  hmass_sub3 -> GetXaxis() -> SetTitle ("m_{#gamma#gamma} (GeV/c^{2})");
  hmass_sub3 -> SetLineColor (4);
  hmass_sub3 -> Sumw2();
  
  sprintf (Hname, "mass_final3");
  hmass_final3 = new TH1D (Hname, Hname, mbins, mmin, mmax);
  hmass_final3 -> GetXaxis() -> SetTitle ("m_{#gamma#gamma} (GeV/c^{2})");
  hmass_final3 -> SetLineColor (4);
  hmass_final3 -> Sumw2();

  //phi histograms to grab mass projections in eta range!
  TH1D *hphi_sub[2][nbins][2][2];   
  TH1D *hphi_sub2[2][nbins][2][2]; 
  TH1D *hphi_raw3[2][nbins];  
  TH1D *hphi_sub3[2][nbins];  

  // tmp histograms to get the y-projections of the Yield[k] [i][j] around the pi0 mass
  TH1D *tphi = new  TH1D ("tphi", "tphi", phibins, phimin, phimax); tphi -> Sumw2();
  TH1D *mphi = new  TH1D ("mphi", "mphi", phibins, phimin, phimax); mphi -> Sumw2();
  TH1D *tphi2 = new  TH1D ("tphi2", "tphi2", 2, phimin, phimax); tphi2 -> Sumw2();
  TH1D *mphi2 = new  TH1D ("mphi2", "mphi2", 2, phimin, phimax); mphi2 -> Sumw2();
  TH1D *tphi3 = new  TH1D ("tphi3", "tphi3", cosbins, phimin, phimax); tphi3 -> Sumw2();
  TH1D *mphi3 = new  TH1D ("mphi3", "mphi3", cosbins, phimin, phimax); mphi3 -> Sumw2();

  for (int a = 0; a < 2; a++)
    for (int k = 0; k < nbins; k++){
      sprintf (Hname, "phi_raw3_%d_%d", a, k);
      hphi_raw3[a][k] = new TH1D (Hname, Hname, cosbins, phimin, phimax);
      hphi_raw3[a][k] -> SetLineColor (k + 1);
      hphi_raw3[a][k] -> Sumw2();
      sprintf (Hname, "phi_sub3_%d_%d", a, k);
      hphi_sub3[a][k] = new TH1D (Hname, Hname, cosbins, phimin, phimax);
      hphi_sub3[a][k] -> SetLineColor (k + 1);
      hphi_sub3[a][k] -> Sumw2();
      
      for (int i = 0; i < 2; i++)
	for (int j = 0; j < 2; j++){	  
	  sprintf (Hname, "phi_sub_%d_%d_%d_%d", a, k, i, j);
	  hphi_sub[a][k][i][j] = new TH1D (Hname, Hname, phibins, phimin, phimax);
	  hphi_sub[a][k][i][j] -> SetLineColor (2 * i + 1);
	  hphi_sub[a][k][i][j] -> Sumw2();
	  sprintf (Hname, "phi_sub2_%d_%d_%d_%d", a, k, i, j);
	  hphi_sub2[a][k][i][j] = new TH1D (Hname, Hname, 2, phimin, phimax);
	  hphi_sub2[a][k][i][j] -> SetLineColor (2 * i + 1);
	  hphi_sub2[a][k][i][j] -> Sumw2();
	}
    }

  // Phi distributions for yellow or blue beam !!!
  TH1D *yphi[2][nbins][2][2];      
  TH1D *yphi2[2][nbins][2][2];   
  TH1D *yphi3[2][nbins];   
  for (int a = 0; a < 2; a++)  
    for (int k = 0; k < nbins; k++){
      sprintf (Hname, "yphi3_arm%d_xf%d", a, k);
      yphi3[a][k] = new TH1D (Hname, Hname, cosbins, phimin, phimax);
      yphi3[a][k] -> SetLineColor (k + 1);
      yphi3[a][k] -> Sumw2();
 
      for (int b = 0; b < 2; b++)    // blue-yellow
	for (int d = 0; d < 2; d++) { // down-up
	  sprintf (Hname, "yphi_arm%d_xf%d_%d_%d", a, k, b, d);
	  yphi[a][k][b][d] = new TH1D (Hname, Hname, phibins, phimin, phimax);
	  yphi[a][k][b][d] -> SetLineColor (d + 1);
	  yphi[a][k][b][d] -> Sumw2();
	  sprintf (Hname, "yphi2_arm%d_xf%d_%d_%d", a, k, b, d);
	  yphi2[a][k][b][d] = new TH1D (Hname, Hname, 2, phimin, phimax);
	  yphi2[a][k][b][d] -> SetLineColor (d + 1);
	  yphi2[a][k][b][d] -> Sumw2();
	}
    }

  // ---------------------------------------------------------------------
  // Polarization asymmetries [arm][xf][beam]
  TH1D *asymP[2][nbins][2];
  TH1D *asymP2[2][nbins][2];
  for (int a = 0; a < 2; a++) 
    for (int k = 0; k < nbins; k++) {
      sprintf (Hname, "asymPol_blue_arm%d_xf%d", a, k);
      asymP[a][k][0] = new TH1D (Hname, Hname, phibins, phimin, phimax); // full detector
      asymP[a][k][0] -> GetXaxis() -> SetTitle ("#varphi (rad)");
      asymP[a][k][0] -> GetYaxis() -> SetTitle ("#epsilon_{pol}");
      asymP[a][k][0] -> SetMarkerStyle (21);
      sprintf (Hname, "asymPol_yellow_arm%d_xf%d", a, k);
      asymP[a][k][1] = new TH1D (Hname, Hname, phibins, phimin, phimax); // full detector
      asymP[a][k][1] -> GetXaxis() -> SetTitle ("#varphi (rad)");
      asymP[a][k][1] -> GetYaxis() -> SetTitle ("#epsilon_{pol}");
      asymP[a][k][1] -> SetMarkerStyle (21);
      
      sprintf (Hname, "asymPol3_blue_arm%d_xf%d", a, k);
      asymP2[a][k][0] = new TH1D (Hname, Hname, 1, 0, 1); // only one bin
      asymP2[a][k][0] -> GetXaxis() -> SetTitle ("#varphi (rad)");
      asymP2[a][k][0] -> GetYaxis() -> SetTitle ("#epsilon_{pol}");
      asymP2[a][k][0] -> SetMarkerStyle (21);
      sprintf (Hname, "asymPol3_yellow_arm%d_xf%d", a, k);
      asymP2[a][k][1] = new TH1D (Hname, Hname, 1, 0, 1); // only one bin
      asymP2[a][k][1] -> GetXaxis() -> SetTitle ("#varphi (rad)");
      asymP2[a][k][1] -> GetYaxis() -> SetTitle ("#epsilon_{pol}");
      asymP2[a][k][1] -> SetMarkerStyle (21);
      
    }
 
  TH1D *asymF[2][nbins][2];  // polarization asymmetries, cleaned from rel.lumi. (fit) !!!
  for (int a = 0; a < 2; a++)  
    for (int k = 0; k < nbins; k++) {
      sprintf (Hname, "asymPol2_blue_arm%d_xf%d", a, k);
      asymF[a][k][0] = new TH1D (Hname, Hname, phibins, phimin, phimax); // full detector
      asymF[a][k][0] -> GetXaxis() -> SetTitle ("#varphi (rad)");
      asymF[a][k][0] -> GetYaxis() -> SetTitle ("#epsilon_{pol}");
      asymF[a][k][0] -> SetMarkerStyle (21);
      sprintf (Hname, "asymPol2_yellow_arm%d_xf%d", a, k);
      asymF[a][k][1] = new TH1D (Hname, Hname, phibins, phimin, phimax); // full detector
      asymF[a][k][1] -> GetXaxis() -> SetTitle ("#varphi (rad)");
      asymF[a][k][1] -> GetYaxis() -> SetTitle ("#epsilon_{pol}");
      asymF[a][k][1] -> SetMarkerStyle (21);
    }
  
  // ---------------------------------------------------------
  // left right asymmetries !!!
  TH1D *asymL[2][nbins][2];  // [xf][beam]
  for (int a = 0; a < 2; a++)  
    for (int k = 0; k < nbins; k++) {  
      sprintf (Hname, "asymSide_blue_arm%d_xf%d", a, k);
      asymL[a][k][0] = new TH1D (Hname, Hname, phibins, phimin, phimax); // full detector
      asymL[a][k][0] -> GetXaxis() -> SetTitle ("#varphi (rad)");
      asymL[a][k][0] -> SetMarkerStyle (21);
      sprintf (Hname, "asymSide_yellow_arm%d_xf%d", a, k);
      asymL[a][k][1] = new TH1D (Hname, Hname, phibins, phimin, phimax); // full detector
      asymL[a][k][1] -> GetXaxis() -> SetTitle ("#varphi (rad)");
      asymL[a][k][1] -> SetMarkerStyle (21);    
    }
  
  // ---------------------------------------------------------
  // Square root asymmetries !!!
  TH1D *asymS[2][nbins][2];  // [xf][beam]
  TH1D *asymS2[2][nbins][2];  // [xf][beam]
  for (int a = 0; a < 2; a++)  
    for (int k = 0; k < nbins; k++) { 
      sprintf (Hname, "asymSqrt_blue_arm%d_xf%d", a, k);
      asymS[a][k][0] = new TH1D (Hname, Hname, phibins /2, phimin, 0); // only left side 
      asymS[a][k][0] -> GetXaxis() -> SetTitle ("#varphi (rad)");
      asymS[a][k][0] -> GetYaxis() -> SetTitle ("#epsilon_{sqrt}");
      asymS[a][k][0] -> SetMarkerStyle (21);
      sprintf (Hname, "asymSqrt_yellow_arm%d_xf%d", a, k);
      asymS[a][k][1] = new TH1D (Hname, Hname, phibins / 2, phimin, 0); // only left side 
      asymS[a][k][1] -> GetXaxis() -> SetTitle ("#varphi (rad)");
      asymS[a][k][1] -> GetYaxis() -> SetTitle ("#epsilon_{sqrt}");
      asymS[a][k][1] -> SetMarkerStyle (21);
      sprintf (Hname, "asymSqrt2_blue_arm%d_xf%d", a, k);
      asymS2[a][k][0] = new TH1D (Hname, Hname, phibins / 2, phimin, 0); // only left side 
      asymS2[a][k][0] -> GetXaxis() -> SetTitle ("#varphi (rad)");
      asymS2[a][k][0] -> GetYaxis() -> SetTitle ("#epsilon_{sqrt}");
      asymS2[a][k][0] -> SetMarkerStyle (21);
      sprintf (Hname, "asymSqrt2_yellow_arm%d_xf%d", a, k);
      asymS2[a][k][1] = new TH1D (Hname, Hname, phibins / 2, phimin, 0); // only left side 
      asymS2[a][k][1] -> GetXaxis() -> SetTitle ("#varphi (rad)");
      asymS2[a][k][1] -> GetYaxis() -> SetTitle ("#epsilon_{sqrt}");
      asymS2[a][k][1] -> SetMarkerStyle (21);
    }

  //functions to fit azimuthal asymmetries!
  TF1 *fitcos  = new TF1 ("an_cos",  an_cos,  -PI, 0., 1); // cosine to sqrt-asymmetry
  TF1 *fitsin  = new TF1 ("an_sin",  an_sin,  -PI, 0., 2); // sine with phase to saqrt-asym
  TF1 *fitcosP = new TF1 ("an_cosP", an_cosP, -PI, PI, 2); // cosine with r.l. to P-asymmetry
  TF1 *fitsinP = new TF1 ("an_sinP", an_sinP, -PI, PI, 3); // sine with phase and r.l. to P-asym
  TF1 *fitcosF = new TF1 ("an_cosF", an_cos,  -PI, PI, 1); // cosine to asymF
  fitcos -> SetLineColor(2);
  fitcosF -> SetLineColor(4);

  double amp_val, amp_err;
  double phi_val, phi_err;
  double rel_val, rel_err;
  double ndf, csq;
      
  // Asymmetries as function of xf !!!
  TH1F *xf_asymfit1[2];
  TH1F *xf_asymfit2[2];
  TH1F *xf_phi0fit2[2];
  TH1F *xf_rellfit3[2];
  TH1F *xf_asymfit3[2];
  TH1F *xf_rellfit4[2];
  TH1F *xf_asymfit4[2];
  TH1F *xf_phi0fit4[2];
  TH1F *xf_asymfit5[2];
 
  TH1F *fit_rndf1[2];
  TH1F *fit_rndf2[2];
  TH1F *fit_rndf3[2];
  TH1F *fit_rndf4[2];
  TH1F *fit_rndf5[2];
  TH1F *xf_an5[2];
  TH1F *xf_an1[2];
  TH1F *xf_an3[2];
  TH1F *xf_an6[2];
  TH1F *xf_an7[2];

  for (int a = 0; a < 2; a++){
    sprintf(Hname, "xf_asymfit1_arm%d", a);
    xf_asymfit1[a] = new TH1F (Hname, Hname, 20, -1, 1);
    xf_asymfit1[a] -> GetXaxis() -> SetTitle ("x_{F}");
    xf_asymfit1[a] -> GetYaxis() -> SetTitle ("raw asymmetry #epsilon");
    SetHistoStyle (xf_asymfit1[a], 20, 2, 1); 

    sprintf(Hname, "xf_asymfit2_arm%d", a);
    xf_asymfit2[a] = new TH1F (Hname, Hname, 20, -1, 1);
    sprintf(Hname, "xf_phi0fit2_arm%d", a);
    xf_phi0fit2[a] = new TH1F (Hname, Hname, 20, -1, 1);
    xf_asymfit2[a] -> GetXaxis() -> SetTitle ("x_{F}");
    xf_asymfit2[a] -> GetYaxis() -> SetTitle ("raw asymmetry #epsilon");
    xf_phi0fit2[a] -> GetXaxis() -> SetTitle ("x_{F}");
    xf_phi0fit2[a] -> GetYaxis() -> SetTitle ("#varphi_{0}");
    SetHistoStyle (xf_asymfit2[a], 24, 2, 1);
    SetHistoStyle (xf_phi0fit2[a], 24, 2, 1);
    SetHistoAxes  (xf_phi0fit2[a], -1, 1, -.5 * PI, 1.5 * PI);


    sprintf(Hname, "xf_rellfit3_arm%d", a);
    xf_rellfit3[a] = new TH1F (Hname, Hname, 20, -1, 1);
    sprintf(Hname, "xf_asymfit3_arm%d", a);
    xf_asymfit3[a] = new TH1F (Hname, Hname, 20, -1, 1);
    xf_rellfit3[a] -> GetXaxis() -> SetTitle ("x_{F}");
    xf_rellfit3[a] -> GetYaxis() -> SetTitle ("rel.lumi.");
    xf_asymfit3[a] -> GetXaxis() -> SetTitle ("x_{F}");
    xf_asymfit3[a] -> GetYaxis() -> SetTitle ("raw asymmetry #epsilon");
    SetHistoStyle (xf_rellfit3[a], 21, 8,  1); 
    SetHistoStyle (xf_asymfit3[a], 21, 8,  1);

    sprintf(Hname, "xf_rellfit4_arm%d", a);  
    xf_rellfit4[a] = new TH1F (Hname, Hname, 20, -1, 1);
    sprintf(Hname, "xf_asymfit4_arm%d", a);
    xf_asymfit4[a] = new TH1F (Hname, Hname, 20, -1, 1);
    sprintf(Hname, "xf_phi0fit4_arm%d", a);
    xf_phi0fit4[a] = new TH1F (Hname, Hname, 20, -1, 1);
    xf_rellfit4[a] -> GetXaxis() -> SetTitle ("x_{F}");
    xf_rellfit4[a] -> GetYaxis() -> SetTitle ("rel.lumi.");
    xf_asymfit4[a] -> GetXaxis() -> SetTitle ("x_{F}");
    xf_asymfit4[a] -> GetYaxis() -> SetTitle ("raw asymmetry #epsilon");
    xf_phi0fit4[a] -> GetXaxis() -> SetTitle ("x_{F}");
    xf_phi0fit4[a] -> GetYaxis() -> SetTitle ("#varphi_{0}");
    SetHistoStyle (xf_rellfit4[a], 25, 8, 1);
    SetHistoStyle (xf_asymfit4[a], 25, 8, 1);
    SetHistoStyle (xf_phi0fit4[a], 24, 8, 1);
    SetHistoAxes  (xf_phi0fit4[a], -1, 1, -.5 * PI, 1.5 * PI);


    // Yes-yes, this is the final fit: subtract the global rel. luminosity and fit plain cosine !!!
    sprintf(Hname, "xf_asymfit5_arm%d", a);  
    xf_asymfit5[a] = new TH1F (Hname, Hname, 20, -1, 1);
    xf_asymfit5[a] -> GetXaxis() -> SetTitle ("x_{F}");
    xf_asymfit5[a] -> GetYaxis() -> SetTitle ("raw asymmetry #epsilon");
    SetHistoStyle (xf_asymfit5[a], 21, 4, 1);
      
    sprintf(Hname, "fit_rndf1_arm%d", a);  
    fit_rndf1[a] = new TH1F (Hname, Hname, 100, 0., 10.);
    sprintf(Hname, "fit_rndf2_arm%d", a);  
    fit_rndf2[a] = new TH1F (Hname, Hname, 100, 0., 10.);
    sprintf(Hname, "fit_rndf3_arm%d", a);  
    fit_rndf3[a] = new TH1F (Hname, Hname, 100, 0., 10.);
    sprintf(Hname, "fit_rndf4_arm%d", a);  
    fit_rndf4[a] = new TH1F (Hname, Hname, 100, 0., 10.);
    sprintf(Hname, "fit_rndf5_arm%d", a);  
    fit_rndf5[a] = new TH1F (Hname, Hname, 100, 0., 10.);
    fit_rndf1[a] -> GetXaxis() -> SetTitle ("#chi^{2} / (n.d.f. - 1)");
    fit_rndf2[a] -> GetXaxis() -> SetTitle ("#chi^{2} / (n.d.f. - 1)");
    fit_rndf3[a] -> GetXaxis() -> SetTitle ("#chi^{2} / (n.d.f. - 1)");
    fit_rndf4[a] -> GetXaxis() -> SetTitle ("#chi^{2} / (n.d.f. - 1)");
    fit_rndf5[a] -> GetXaxis() -> SetTitle ("#chi^{2} / (n.d.f. - 1)");

    // And look: then there is the analyzing power !!!
    sprintf(Hname, "xf_an5_arm%d", a);  
    xf_an5[a] = new TH1F (Hname, Hname, 20, -1, 1);
    xf_an5[a] -> GetXaxis() -> SetTitle ("x_{F}");
    xf_an5[a] -> GetYaxis() -> SetTitle ("A_{N}");
    SetHistoStyle (xf_an5[a], 21, 4, 1);
    sprintf(Hname, "xf_an1_arm%d", a);  
    xf_an1[a] = new TH1F (Hname, Hname, 20, -1, 1);
    xf_an1[a] -> GetXaxis() -> SetTitle ("x_{F}");
    xf_an1[a] -> GetYaxis() -> SetTitle ("A_{N}");
    SetHistoStyle (xf_an1[a], 21, 2, 1);
    sprintf(Hname, "xf_an3_arm%d", a);  
    xf_an3[a] = new TH1F (Hname, Hname, 20, -1, 1);
    xf_an3[a] -> GetXaxis() -> SetTitle ("x_{F}");
    xf_an3[a] -> GetYaxis() -> SetTitle ("A_{N}");
    SetHistoStyle (xf_an3[a], 25, 8, 1);
    sprintf(Hname, "xf_an6_arm%d", a);  
    xf_an6[a] = new TH1F (Hname, Hname, 20, -1, 1);
    xf_an6[a] -> GetXaxis() -> SetTitle ("x_{F}");
    xf_an6[a] -> GetYaxis() -> SetTitle ("A_{N}");
    SetHistoStyle (xf_an6[a], 25, 2, 1);
    sprintf(Hname, "xf_an7_arm%d", a);  
    xf_an7[a] = new TH1F (Hname, Hname, 20, -1, 1);
    xf_an7[a] -> GetXaxis() -> SetTitle ("x_{F}");
    xf_an7[a] -> GetYaxis() -> SetTitle ("A_{N}");
    SetHistoStyle (xf_an7[a], 25, 4, 1);
  }

  // ============= Let's roll squared: get the data !!!
  int arm;
  int pol, polB, polY;
  Float_t xf;
  Float_t phi, phi3;
  Float_t phiyellow, phiblue, phiyellow2, phiblue2;
  Float_t pt;

  //initialize kdimuon tree
  Int_t dimuonID;
  Int_t runID;
  Int_t spillID, eventID;
  Int_t negTrackID, posTrackID;
  Int_t negHits, posHits;
  Float_t xF, xT, xB, mass;
  Float_t dx, dy, dz;
  Float_t dpx, dpy, dpz;
  Float_t px1, py1, pz1;
  Float_t px2, py2, pz2;
  Float_t trackSeparation, chisq_dimuon;
  Int_t target, dump;
  Int_t targetPos;
  Float_t m3hm, m3hs, m3vm, m3vs;
  Float_t m2hm, m2hs, m2vm, m2vs;
  Float_t dhm, dvm;
  Float_t costh, phi;
  Float_t eta;
  TLorentzVector lordm;// = new TLorentzVector;

  if(Trig == 0)  sprintf (inName, "./nDST/Analysis_roadset%d_R005_V001.root", Train);
  if(Trig == 1)  sprintf (inName, "./nDST/Analysis_roadset%d_R005_V001.root", Train);
  if(Trig == 2)  sprintf (inName, "./nDST/Analysis_mc_drellyan_LD2_M013_S001.root", Train);

  TFile *inFile1 = new TFile (inName);
  gROOT -> cd();

  // ====================================================== Read the reconstructed cluster pairs !!!
  //TTree *YieldTree = (TTree*) inFile1 -> Get ("YieldTree");
  TTree *YieldTree = (TTree*) inFile1 -> Get ("kdimuon"); 
  YieldTree -> SetBranchAddress ("dimuonID",        &dimuonID);
  YieldTree -> SetBranchAddress ("runID",           &runID);
  YieldTree -> SetBranchAddress ("eventID",         &eventID);
  YieldTree -> SetBranchAddress ("spillID",         &spillID);
  YieldTree -> SetBranchAddress ("posTrackID",    &posTrackID);
  YieldTree -> SetBranchAddress ("negTrackID",    &negTrackID);
  YieldTree -> SetBranchAddress ("posHits",    &posHits);
  YieldTree -> SetBranchAddress ("negHits",    &negHits);
  YieldTree -> SetBranchAddress ("dx",              &dx);
  YieldTree -> SetBranchAddress ("dy",              &dy);
  YieldTree -> SetBranchAddress ("dz",              &dz);
  YieldTree -> SetBranchAddress ("dpx",             &dpx);
  YieldTree -> SetBranchAddress ("dpy",             &dpy);
  YieldTree -> SetBranchAddress ("dpz",             &dpz);
  YieldTree -> SetBranchAddress ("mass",            &mass);
  YieldTree -> SetBranchAddress ("xF",              &xF);
  YieldTree -> SetBranchAddress ("xB",              &xB);
  YieldTree -> SetBranchAddress ("costh",              &costh);
  YieldTree -> SetBranchAddress ("phi",              &phi);
  YieldTree -> SetBranchAddress ("trackSeparation", &trackSeparation);
  YieldTree -> SetBranchAddress ("chisq_dimuon",    &chisq_dimuon);
  YieldTree -> SetBranchAddress ("px1",             &px1);
  YieldTree -> SetBranchAddress ("py1",             &py1);
  YieldTree -> SetBranchAddress ("pz1",             &pz1);
  YieldTree -> SetBranchAddress ("px2",             &px2);
  YieldTree -> SetBranchAddress ("py2",             &py2);
  YieldTree -> SetBranchAddress ("pz2",             &pz2);
  YieldTree -> SetBranchAddress ("target",          &target);
  YieldTree -> SetBranchAddress ("dump",            &dump);
  YieldTree -> SetBranchAddress ("targetPos",       &targetPos);
  
  int nentries = YieldTree -> GetEntries();
  cout << "Number of entries: " << nentries << endl;
  for (int i = 0; i < nentries; i++) {
  //for (int i = 0; i < 10000; i++) {
    YieldTree -> GetEntry (i);
    if(i%10000 == 0) cout << "entry " << i << endl;

    //Now do the kinematic cuts!
    if(target == 0){continue;}
    arm = 1;
    xf = xF;
    lordm.SetXYZM(dpx, dpy, dpz, mass);
    phi = lordm.Phi();
    if(lordm.Pt() < 0.5){continue;}
    phiyellow = phi - PI;
    if(phiyellow < -PI){
      phiyellow = phiyellow + 2*PI;
    }
    phiblue = phi;

    //make a left right phi!
    phiyellow2 = phiyellow - PI/2;
    if(phiyellow2 < -PI){phiyellow2 = phiyellow2 + 2*PI;}
    phiblue2 = phiblue - PI/2;
    if(phiblue2 < -PI){phiblue2 = phiblue2 + 2*PI;}
    phi3 = phi - PI/2;
    if(phi3 < -PI){phi3 = phi3 + 2*PI;}

    if(Trig == 0 || Trig == 2 || Trig == 3){if(xf < 0.2 || xf > 0.4){continue;}}
    if(Trig == 1){if(xf < 0.3 || xf > 0.7){continue;}}

    if(nbins == 1){k = 0;}
    else{
      if(Trig == 0 || Trig == 2){int k = int (10 * (xf - 0.2));}
      if(Trig == 1){int k = int (10 * (xf - 0.3));}
    }

    if (k < 0) continue;
    if (k > nbins-1) k = nbins - 1;
    //if (k > nbins-1) continue;
    //cout << i << " " << k << " " << xf <<  " " << rxy_i << " " << rxy_j << endl;
    
    //get the same event spincombo
    polB = BRand -> Uniform(2);
    polY = YRand -> Uniform(2);
    if(i%100000 == 0)  cout << "entry, polB, polY " << i << " " << polB << " " << polY << endl;

    //cout << "arm, k, phiy, phib, phi " << i << " " << arm << " " << k << " " << phiyellow << " " << phiblue << " " << phi << endl;
    Yield[arm][k][0][polB] -> Fill (mass, phiblue);
    Yield2[arm][k][0][polB] -> Fill (mass, phiblue2);
    Yield[arm][k][1][polY] -> Fill (mass, phiyellow);
    Yield2[arm][k][1][polY] -> Fill (mass, phiyellow2);
   
    Yield3[arm][k] -> Fill (mass, phi);
    yxfmass  -> Fill (mass,xf);
    yeta  -> Fill (eta);
    yxfmasspt  -> Fill (mass,xf,pt);
    yxfmasseta  -> Fill (mass,xf,eta);


    
  }

  inFile1 -> Close();
  gROOT -> cd();

  // ================================================================== mass peak determination
  //                                                                    asymmetry calculation
  
  //Canvas to draw phi dists
  TCanvas *cpb[2][2];
  TCanvas *cpa[2][2];
  TCanvas *cpb2[2][2];
  TCanvas *cpa2[2][2];
  TCanvas *c1;
  TCanvas *c2;

  c1 = new TCanvas();
  for (int i = 0; i < 2; i++)
    for (int j = 0; j < 2; j++){
      sprintf(Hname, "cpb_%d_%d", i, j);
      cpb[i][j] = new TCanvas(Hname, Hname, 1800, 1200);
      cpb[i][j] -> Divide(3, 3);
      sprintf(Hname, "cpa_%d_%d", i, j);
      cpa[i][j] = new TCanvas(Hname, Hname, 1800, 1200);
      cpa[i][j] -> Divide(3, 3);
      sprintf(Hname, "cpb2_%d_%d", i, j);
      cpb2[i][j] = new TCanvas(Hname, Hname, 1200, 400);
      cpb2[i][j] -> Divide(2, 1);
      sprintf(Hname, "cpa2_%d_%d", i, j);
      cpa2[i][j] = new TCanvas(Hname, Hname, 1200, 400);
      cpa2[i][j] -> Divide(2, 1);
    }

  for (int a = 0; a < 2; a++){ // These are the slices in Arms !!
    if(a == 0) sprintf (inArm, "South");
    else if(a == 1) sprintf (inArm, "North");
    Int_t binswap = 1;
    if(a == 1){binswap = -1;}
    if(a == 0){sprintf(Beam,"yellow");}
    if(a == 1){sprintf(Beam,"blue");}

    for (int k = 0; k < nbins; k++) { // These are the slices in xf !!!
       // Mass distribution for the mixed events !!!
      if(Bkgnd == 1){
	tmass3 = Yieldmix3[a][k] -> ProjectionX();
	hmixmass3 -> Reset();
	hmixmass3 -> Add (tmass3);
	tmass = Yieldmix[a][k] -> ProjectionX();
	hmixmass -> Reset();
	hmixmass -> Add (tmass);
	tmass2 = Yieldmix2[a][k] -> ProjectionX();
	hmixmass2 -> Reset();
	hmixmass2 -> Add (tmass2);
      }
      //labels!
      float xfTitleMin, xfTitleMax;
      float phiTitleMin, phiTitleMax;
      if(Trig == 0 || Trig == 2 || Trig == 3){
	xfTitleMin = 0.1 * float (k) + 0.2;
	xfTitleMax = 0.1 * float (k) + 0.3;
	if(NBins == 1){xfTitleMin = 0.2, xfTitleMax = 0.4;}
      }
      if( Trig == 1){
	xfTitleMin = 0.1 * float (k) + 0.3;
	xfTitleMax = 0.1 * float (k) + 0.4;
	if(NBins == 1){xfTitleMin = 0.4, xfTitleMax = 0.7;}
      }
      
      //fit range!
      printf("//////////////////////////////////");
      printf("GET PARAMETERS FOR XF BIN %d \n", k);
      ///////////////////////////////////////////////////////////
      ///////////////////////////////////////////////////////////
      double pi0peak;
      double pi0width;
      int pi0_center, pi0_2sigma;
      int pi0_left, pi0_right;
      int pi0_range;

      c1->cd();
      printf("Doing mass distributions for %s xf bin%d, and beams B%dY%d \n", inArm, a, k);
      if(Bkgnd == 0){
	tmass3 = Yield3[a][k] -> ProjectionX();
	hmass3 -> Reset();
	hmass3 -> Add (tmass3);
	hmass_sub3 -> Reset();
	hmass_sub3 -> Add (hmass3);
      }else{
	tmass3 -> Reset();
	tmass3 = Yield3[a][k] -> ProjectionX();
	hmass3 -> Reset();
	hmass3 -> Add (tmass3);
	hmass_ratio3 -> Reset();
	hmass_ratio3 -> Add (tmass3);
	hmass_ratio3 -> Divide (hmixmass3);
	//hmass_ratio3 -> Fit (fitratio, "R");
	mixnorm3 = fitratio -> GetParameter (0);
	printf ("mixed event normalization : %5.3f \n", mixnorm3);
	hmix_norm3 -> Reset();
	hmix_norm3 -> Add (hmixmass3);
	hmix_norm3 -> Scale (mixnorm3);
	hmass_sub3 -> Reset();
	hmass_sub3 -> Add (hmass3, hmix_norm3, 1., -1.);
      }
      tmass3 -> Reset();
      tmass3 -> Add(hmass_sub3);
      Hmass[a][k] -> Add (tmass3);
      sprintf (Hname, "%s %s for %1.1f < x_{F} < %1.1f", inArm, inTrig, xfTitleMin, xfTitleMax);
      tmass3 -> SetTitle(Hname);
      //tmass3 -> Fit (drawboth3[a][k], "R");
      double tmassmax3 = tmass3 -> GetMaximum();
      drawgamma3 -> SetParameters(drawboth3[a][k] -> GetParameter(0),drawboth3[a][k] -> GetParameter(1),drawboth3[a][k] -> GetParameter(2),drawboth3[a][k] -> GetParameter(3),drawboth3[a][k] -> GetParameter(7),drawboth3[a][k] -> GetParameter(8),drawboth3[a][k] -> GetParameter(9),drawboth3[a][k] -> GetParameter(10));
      drawgaus3 -> SetParameters(drawboth3[a][k] -> GetParameter(4),drawboth3[a][k] -> GetParameter(5),drawboth3[a][k] -> GetParameter(6));
      printf ("============================\n");
      printf ("Eta mass fit: %f (%f) \n", pi0peak, pi0width);

      // Get the 2.5 * sigma bins around the eta peaks !!!	 
      if(Trig == 0 || Trig == 2) pi0_range = 2.0;
      if(Trig == 1) pi0_range = 2.0;
      pi0peak  = drawboth3[a][k] -> GetParameter (5);
      pi0width = drawboth3[a][k] -> GetParameter (6);
      pi0_center = int (pi0peak / (mmax - mmin) * mbins) + 1;
      pi0_2sigma = int (pi0_range * pi0width / (mmax - mmin) * mbins) + 1;
      pi0_left  = pi0_center - pi0_2sigma;
      pi0_right = pi0_center + pi0_2sigma;
      if(Peak == 1){
	pi0_right = 45;
        pi0_left = 30;
	pi0_left = pi0_center - 3.5 * pi0_2sigma;
	pi0_right = pi0_center - 1.5 * pi0_2sigma;
      }
      //printf("The mass bins to project in phi for xf bin %d are:  center %d, left %d, right %d \n", k, pi0_center, pi0_left, pi0_right);
      if(Peak == 2){
	pi0_left = 70;
	pi0_right = 85;
	pi0_left = pi0_center + 1.5 * pi0_2sigma;
	pi0_right = pi0_center + 3.5 * pi0_2sigma;
      }
      if(Peak == 3){
        //pi0_left = pi0_right + 2;
        pi0_left = 100;
        //pi0_center = pi0_left + pi0_2sigma;
        pi0_center = 75;
        //pi0_right = pi0_center + pi0_2sigma;
        pi0_right = 130;
        //pi0peak = float(pi0_center)/100;
      }
      printf("The mass bins to project for %s xfbin %d are:  center %d, left %d, right %d \n", inArm, k,  pi0_center, pi0_left, pi0_right);
      if(Peak == 0){
	TLine *lc = new TLine (pi0peak, 0, pi0peak, tmassmax3);
	TLine *ll = new TLine (pi0peak - pi0_range * pi0width, 0, pi0peak - pi0_range * pi0width, tmassmax3);
	TLine *lr = new TLine (pi0peak + pi0_range * pi0width, 0, pi0peak + pi0_range * pi0width, tmassmax3);
	TLine *l0 = new TLine (mmin, 0, mmax, 0);
      }else{
	TLine *lc = new TLine (pi0peak, 0, pi0peak, tmassmax3);
	TLine *ll = new TLine (float(pi0_left)/100, 0, float(pi0_left)/100, tmassmax3);
	TLine *lr = new TLine (float(pi0_right)/100, 0, float(pi0_right)/100, tmassmax3);
	TLine *l0 = new TLine (mmin, 0, mmax, 0);
      }
      lc -> SetLineWidth (8);
      lc -> SetLineColor (4);
      ll -> SetLineColor (2);
      lr -> SetLineColor (2);
      lc -> Draw();
      ll -> Draw();
      lr -> Draw();
      l0 -> Draw();
      //hmass3[i][j] -> Draw("same");
      //hmix_norm3[i][j] -> Draw("same");
      drawgamma3 -> Draw("same");
      drawgaus3 -> Draw("same");
      sprintf (Hname, "./images_xf_rxy%d%d/mass3_peak%d_trig%d_nbins%d_arm%d_xf%d.gif", RMIN, RMAX, Peak, Trig, nbins, a, k);
      if(Final == 1)sprintf (Hname, "./images_xf/mass3_peak%d_trig%d_nbins%d_arm%d_xf%d.gif", Peak, Trig, nbins, a, k);
      c1-> SaveAs(Hname);

      tmass3 -> Reset();
      tmass3 -> Add(hmass_sub3);
      //Set the phi distributions for cosavg!
      //tphi3 = Yield3[a][k] -> ProjectionY ("tphi3", pi0_left + 1, pi0_right + 1);
      //mphi3 = Yieldmix3[a][k]    -> ProjectionY ("mphi3", pi0_left + 1, pi0_right + 1);
      tphi3 = Yield3[a][k] -> ProjectionY ("tphi3", 1,140);
      mphi3 = Yieldmix3[a][k]    -> ProjectionY ("mphi3", 1, 140);
      mphi3 -> Scale (mixnorm3);
      hphi_raw3[a][k] -> Reset();
      hphi_raw3[a][k] -> Add (tphi3);
      hphi_sub3[a][k] -> Reset();
      hphi_sub3[a][k] -> Add (tphi3, mphi3, 1., -1.);
    
      
      //Do it for the bigger phi bins !!!
      printf("//////////////////////////////////");
      printf("BIG PHI BIN PART FOR XF BIN %d \n", k);
      ///////////////////////////////////////////////////////////
      ///////////////////////////////////////////////////////////
      //one phi bin at a time, then subtract background!!

      for (int i = 0; i < 2; i++)
	for (int j = 0; j < 2; j++)
	  for(int p = 0; p < 2; p++){
	    if (i == 0) sprintf (inBeam, "Blue");
	    else if (i == 1) sprintf (inBeam, "Yellow");
	    if (j == 0) sprintf (inPol, "Down");
	    else if (j == 1) sprintf (inPol, "Up");
	    if (p == 0)sprintf (LRdir, "Left");
	    else if (p == 1)sprintf (LRdir, "Right");
	    c1->cd();
	    //Get invariant mass
	    printf("Doing mass distributions for %s xf bin%d, phi bin %s, %s beam, %s direction \n", inArm, k, LRdir, inBeam, inPol);
	    if(Bkgnd == 0){
	      //tmass2 -> Reset();
	      tmass2 = Yield2[a][k][i][j] -> ProjectionX("tmass2", p+1, p+1);
	      hmass2[p][i][j] -> Reset();
	      hmass2[p][i][j] -> Add (tmass2);
	      hmass_sub2[p][i][j] -> Reset();
	      hmass_sub2[p][i][j] -> Add (hmass2[p][i][j]);
	    }else{
	      //Subtract off mixed events
	      tmass2 -> Reset();
	      tmass2 = Yield2[a][k][i][j] -> ProjectionX("tmass2", p+1, p+1);
	      hmass2[p][i][j] -> Reset();
	      hmass2[p][i][j] -> Add (tmass2);
	      hmass_ratio2[p][i][j] -> Reset();
	      hmass_ratio2[p][i][j] -> Add (tmass2);
	      hmass_ratio2[p][i][j] -> Divide (hmixmass2);
	      //hmass_ratio2[p][i][j] -> Fit (fitratio, "R");
	      mixnorm2[p][i][j] = fitratio -> GetParameter (0);
	      printf ("mixed event normalization %s %s: %5.3f \n", inBeam, inPol, mixnorm2[p][i][j]);
	      hmix_norm2[p][i][j] -> Reset();
	      hmix_norm2[p][i][j] -> Add (hmixmass2);
	      hmix_norm2[p][i][j] -> Scale (mixnorm2[p][i][j]);
	      hmass_sub2[p][i][j] -> Reset();
	      hmass_sub2[p][i][j] -> Add (hmass2[p][i][j], hmix_norm2[p][i][j], 1., -1.);
	    }
	    //Scale the gamma function!
	    tmass2 -> Reset();
	    tmass2 -> Add(hmass_sub2[p][i][j]);
	    tmass2 -> Divide(tmass3);
	    //tmass2 -> Fit(fitratio2, "R");
	    double scalebg2 = fabs(fitratio2 -> GetParameter(0));

	    drawboth2[k][p][i][j] -> SetParameters(scalebg2*drawboth3[a][k] -> GetParameter(0),drawboth3[a][k] -> GetParameter(1),drawboth3[a][k] -> GetParameter(2),drawboth3[a][k] -> GetParameter(3),scalebg2*drawboth3[a][k] -> GetParameter(4),drawboth3[a][k] -> GetParameter(5),drawboth3[a][k] -> GetParameter(6),scalebg2*drawboth3[a][k] -> GetParameter(7),drawboth3[a][k] -> GetParameter(8),drawboth3[a][k] -> GetParameter(9),scalebg2*drawboth3[a][k] -> GetParameter(10));
	    //Proceed with bg subtraction!
	    cpb2[i][j] -> cd(p+1);
	    sprintf (Hname, "%s %s %s %s for %1.1f < x_{F} < %1.1f, %s", inArm, inTrig, inBeam, inPol, xfTitleMin, xfTitleMax, LRdir);
	    hmass_sub2[p][i][j] -> SetTitle(Hname);
	    //Fit or Draw!
	    //if(k == 2) hmass_sub2[p][i][j] -> Rebin(2);
	    //hmass_sub2[p][i][j] -> Fit(drawboth2[k][p][i][j], "R");
	    hmass_sub2[p][i][j] -> Draw();
	    drawgamma2[p][i][j] -> SetParameters(drawboth2[k][p][i][j] -> GetParameter(0),drawboth2[k][p][i][j] -> GetParameter(1),drawboth2[k][p][i][j] -> GetParameter(2),drawboth2[k][p][i][j] -> GetParameter(3),drawboth2[k][p][i][j] -> GetParameter(7),drawboth2[k][p][i][j] -> GetParameter(8),drawboth2[k][p][i][j] -> GetParameter(9),drawboth2[k][p][i][j] -> GetParameter(10));
	    drawgaus2[p][i][j] -> SetParameters(drawboth2[k][p][i][j] -> GetParameter(4),drawboth2[k][p][i][j] -> GetParameter(5),drawboth2[k][p][i][j] -> GetParameter(6));	

	    printf ("============================\n");
	    printf ("Eta mass fit: %f (%f) \n", pi0peak, pi0width);
	    printf("The BIG PHI BIN mass bins to project for %s xfbin %d, phibin %d, %s beam, %s direction are:  center %d, left %d, right %d \n", inArm, k, p, inBeam, inPol, pi0_center, pi0_left, pi0_right);
	    double tmassmax2 = hmass2[p][i][j] -> GetMaximum();
	    TLine *lc = new TLine (pi0peak, 0, pi0peak, tmassmax2);
	    TLine *ll = new TLine (pi0peak - pi0_range * pi0width, 0, pi0peak - pi0_range * pi0width, tmassmax2);
	    TLine *lr = new TLine (pi0peak + pi0_range * pi0width, 0, pi0peak + pi0_range * pi0width, tmassmax2);
	    TLine *l0 = new TLine (mmin, 0, mmax, 0);
	    lc -> SetLineWidth (8);
	    lc -> SetLineColor (4);
	    ll -> SetLineColor (2);
	    lr -> SetLineColor (2);
	    lc -> Draw();
	    ll -> Draw();
	    lr -> Draw();
	    l0 -> Draw();
	    //hmass2[p][i][j] -> Draw("same");
	    //hmix_norm2[p][i][j] -> Draw("same");
	    drawgamma2[p][i][j] -> Draw("same");
	    drawgaus2[p][i][j] -> Draw("same");

	    //Let's try to subtract gamma function!
	    hmass_final2[p][i][j] -> Reset();
	    hmass_final2[p][i][j] -> Add(hmass_sub2[p][i][j]);
	    //if(scalebg2 > 0)hmass_final2[p][i][j] -> Add(drawgamma2[p][i][j], -1);
	    cpa2[i][j] -> cd(p+1);
	    int integral = hmass_final2[p][i][j] -> Integral(pi0_left, pi0_right);
	    sprintf (Hname, "%d COUNTS! %s %s %s %s for %1.1f < x_{F} < %1.1f, %s", integral, inArm, inTrig, inBeam, inPol, xfTitleMin, xfTitleMax, LRdir);
	    hmass_final2[p][i][j] -> SetTitle(Hname);
	    hmass_final2[p][i][j] -> Draw();
	    lc -> Draw();
	    ll -> Draw();
	    lr -> Draw();
	    l0 -> Draw();
	    drawgamma2[p][i][j] -> Draw("same");
	    drawgaus2[p][i][j] -> Draw("same");

	    tmass2 -> Reset();

	    // Set the phi distributions !!!
	    //hphi_sub2[a][k][i][j] -> SetBinContent(p+1, hmass_final2[p][i][j] -> Integral(pi0_left, pi0_right));
	    hphi_sub2[a][k][i][j] -> SetBinContent(p+1, hmass_final2[p][i][j] -> Integral(1, 140));
	  }//end of slices in big phi, pol direction!  
      //Save Canvas
      if(Peak == 0){
	for (int i = 0; i < 2; i++)
	  for (int j = 0; j < 2; j++){
	  cpb2[i][j] -> cd();
          sprintf (Hname, "./images_mass_xf/mass2_nbins%d_trig%d_arm%d_xf%d_B%d_D%d.gif", nbins, Trig, a, k, i, j);
	  cpb2[i][j] -> SaveAs(Hname);
	  //cpa2[i][j] -> cd();
	  //sprintf (Hname, "./images_mass_xf/mass2sub_nbins%d_trig%d_arm%d_xf%d_B%d_D%d.gif", nbins, Trig, a, k, i, j);
	  //cpa2[i][j] -> SaveAs(Hname);
	  }
      }
      printf("//////////////////////////////////");
      printf("LITTLE PHI BIN PART FOR XF BIN %d \n", k);
      //one phi bin at a time, then subtract background!!
      for(int i = 0; i < 2; i++)
	for (int j = 0; j < 2; j++)
	  for(int p = 0; p < phibins; p++){
	    if (i == 0) sprintf (inBeam, "Blue");
	    else if (i == 1) sprintf (inBeam, "Yellow");
	    if (j == 0) sprintf (inPol, "Down");
	    else if (j == 1) sprintf (inPol, "Up");
	    phiTitleMin = PI/(phibins/2) * float(p) - PI;
	    phiTitleMax = PI/(phibins/2) * float(p) - PI + PI/(phibins/2);
	    c1->cd();

	    //Get the invariant mass
	    if(Bkgnd == 0){
	      //Get the invariant mass
	      //tmass -> Reset();
	      tmass = Yield[a][k][i][j] -> ProjectionX("tmass", p+1, p+1);
	      hmass[p][i][j] -> Reset();
	      hmass[p][i][j] -> Add (tmass);
	      hmass_sub[p][i][j] -> Reset();
	      hmass_sub[p][i][j] -> Add (hmass[p][i][j]);
	    }else{
	      //Subtract off mixed events
	      printf("Doing mass distributions for %s xf bin%d, phi bin %d,  %s beam, %s direction \n", inArm, k, p, inBeam, inPol); 
	      tmass -> Reset();
	      tmass = Yield[a][k][i][j] -> ProjectionX("tmass", p+1, p+1);
	      hmass[p][i][j] -> Reset();
	      hmass[p][i][j] -> Add (tmass);
	      hmass_ratio[p][i][j] -> Reset();
	      hmass_ratio[p][i][j] -> Add (tmass);
	      hmass_ratio[p][i][j] -> Divide (hmixmass);
	      //hmass_ratio[p][i][j] -> Fit(fitratio, "R");
	      mixnorm[p][i][j] = fitratio -> GetParameter (0);
	      printf ("mixed event normalization %d %d: %5.3f \n", i, j, mixnorm[p][i][j]);	
	      hmix_norm[p][i][j] -> Reset();
	      hmix_norm[p][i][j] -> Add (hmixmass);
	      hmix_norm[p][i][j] -> Scale (mixnorm[p][i][j]);	
	      hmass_sub[p][i][j] -> Reset();
	      hmass_sub[p][i][j] -> Add (hmass[p][i][j], hmix_norm[p][i][j], 1., -1.);
	    }
	    //Scale the gamma function!
	    tmass -> Reset();
	    tmass -> Add(hmass_sub[p][i][j]);
	    tmass -> Divide(tmass3);
	    //tmass -> Fit(fitratio2, "R");
	    double scalebg = fabs(fitratio2 -> GetParameter(0));
	    drawboth[k][p][i][j] -> SetParameters(scalebg*drawboth3[a][k] -> GetParameter(0),drawboth3[a][k] -> GetParameter(1),drawboth3[a][k] -> GetParameter(2),drawboth3[a][k] -> GetParameter(3),scalebg*drawboth3[a][k] -> GetParameter(4),drawboth3[a][k] -> GetParameter(5),drawboth3[a][k] -> GetParameter(6),scalebg*drawboth3[a][k] -> GetParameter(7),drawboth3[a][k] -> GetParameter(8),drawboth3[a][k] -> GetParameter(9),scalebg*drawboth3[a][k] -> GetParameter(10));
	    //Proceed with bg subtraction!
	    cpb[i][j] -> cd(p+1);
	    sprintf (Hname, "%s %s %s %s for %1.1f < x_{F} < %1.1f, %1.2f < #phi < %1.2f", inArm, inTrig, inBeam, inPol, xfTitleMin, xfTitleMax, phiTitleMin, phiTitleMax);
	    hmass_sub[p][i][j] -> SetTitle(Hname);
	    //Fit or Draw!
	    //if(k < 2) hmass_sub[p][i][j] -> Fit(drawboth[k][p][i][j], "RL");
	    hmass_sub[p][i][j] -> Draw();
	    drawgamma[p][i][j] -> SetParameters(drawboth[k][p][i][j] -> GetParameter(0),drawboth[k][p][i][j] -> GetParameter(1),drawboth[k][p][i][j] -> GetParameter(2),drawboth[k][p][i][j] -> GetParameter(3),drawboth[k][p][i][j] -> GetParameter(7),drawboth[k][p][i][j] -> GetParameter(8),drawboth[k][p][i][j] -> GetParameter(9),drawboth[k][p][i][j] -> GetParameter(10));
	    drawgaus[p][i][j] -> SetParameters(drawboth[k][p][i][j] -> GetParameter(4),drawboth[k][p][i][j] -> GetParameter(5),drawboth[k][p][i][j] -> GetParameter(6));

	    printf ("============================\n");
	    printf ("Eta mass fit: %f (%f) \n", pi0peak, pi0width);
	    printf("The LITTLE PHI BIN mass bins to project for %s xfbin %d, phibin %d, %s beam, %s direction are:  center %d, left %d, right %d \n", inArm, k, p, inBeam, inPol, pi0_center, pi0_left, pi0_right);
	    double tmassmax = hmass[p][i][j] -> GetMaximum();
	    TLine *lc = new TLine (pi0peak, 0, pi0peak, tmassmax);
	    TLine *ll = new TLine (pi0peak - pi0_range * pi0width, 0, pi0peak - pi0_range * pi0width, tmassmax);
	    TLine *lr = new TLine (pi0peak + pi0_range * pi0width, 0, pi0peak + pi0_range * pi0width, tmassmax);
	    TLine *l0 = new TLine (mmin, 0, mmax, 0);
	    lc -> SetLineWidth (8);
	    lc -> SetLineColor (4);
	    ll -> SetLineColor (2);
	    lr -> SetLineColor (2);
	    lc -> Draw();
	    ll -> Draw();
	    lr -> Draw();
	    l0 -> Draw();
	    //hmix_norm[p][i][j] -> Draw("same");
	    //hmass[p][i][j] -> Draw("same");
	    drawgamma[p][i][j] -> Draw("same");
	    drawgaus[p][i][j] -> Draw("same");
	    //Let's try to subtract gamma function!
	    hmass_final[p][i][j] -> Reset();
	    hmass_final[p][i][j] -> Add(hmass_sub[p][i][j]);
	    //hmass_final[p][i][j] -> Add(drawgamma[p][i][j], -1);
	    cpa[i][j] -> cd(p+1);
	    int integral = hmass_final[p][i][j] -> Integral(pi0_left, pi0_right);
	    sprintf (Hname, "%d COUNTS! %s %s %s %s for %1.1f < x_{F} < %1.1f, %s", integral, inArm, inTrig, inBeam, inPol, xfTitleMin, xfTitleMax, LRdir);
	    hmass_final[p][i][j] -> SetTitle(Hname);
	    hmass_final[p][i][j] -> Draw();
	    lc -> Draw();
	    ll -> Draw();
	    lr -> Draw();
	    l0 -> Draw();
	    drawgamma[p][i][j] -> Draw("same");
	    drawgaus[p][i][j] -> Draw("same");
	    tmass -> Reset();

	    // Set the phi distributions !!!
	    //hphi_sub[a][k][i][j] -> SetBinContent(p+1, hmass_final[p][i][j] -> Integral(pi0_left,pi0_right));
	    hphi_sub[a][k][i][j] -> SetBinContent(p+1, hmass_final[p][i][j] -> Integral(1, 140));
	  }//end of slices in phi, pol direction!
    
      //Save Canvas
      if(Peak == 0){
	for (int i = 0; i < 2; i++)
	  for (int j = 0; j < 2; j++){
	    cpb[i][j] -> cd();
	    sprintf (Hname, "./images_mass_xf/mass_nbins%d_trig%d_arm%d_xf%d_B%d_D%d.gif", nbins, Trig, a, k, i, j);
	    cpb[i][j] -> SaveAs(Hname);
	    cpa[i][j] -> cd();
	    sprintf (Hname, "./images_mass_xf/masssub_nbins%d_trig%d_arm%d_xf%d_B%d_D%d.gif", nbins, Trig, a, k, i, j);
	    cpa[i][j] -> SaveAs(Hname);
	  }
      }
      //Get the #eta meson Yields in phi!!
      printf("NOW GETTING THE SPIN, PHI DEPENDENT YIELDS FOR %s xf bin %d \n", inArm, k);
      yphi[a][k][0][0] -> Add (hphi_sub[a][k][0][0]); // blue down
      yphi[a][k][0][1] -> Add (hphi_sub[a][k][0][1]); // blue up
      yphi[a][k][1][0] -> Add (hphi_sub[a][k][1][0]); // yellow down
      yphi[a][k][1][1] -> Add (hphi_sub[a][k][1][1]); // yellow up
      yphi2[a][k][0][0] -> Add (hphi_sub2[a][k][0][0]); // blue down
      yphi2[a][k][0][1] -> Add (hphi_sub2[a][k][0][1]); // blue up
      yphi2[a][k][1][0] -> Add (hphi_sub2[a][k][1][0]); // yellow down
      yphi2[a][k][1][1] -> Add (hphi_sub2[a][k][1][1]); // yellow up   
      yphi3[a][k] -> Add (hphi_sub3[a][k]); 
    
      c1 -> cd();
      // Calculate polarization asymmetries (asymP),left-right and square root asymmetries (asymS) !!!
      double n1, n2, n3, n4;
      double e1, e2, e3, e4;
      double asym_val, asym_err;
      double asym_val_up,asym_err_up,asym_val_down,asym_err_down;
      double asym_val_left,asym_err_left,asym_val_right,asym_err_right;
      //sqrt asymmetry
      for (int b = 0; b < 2; b++) {        // blue-yellow      
	for (int p = 0; p < phibins / 2; p++) {
	  n1 = yphi[a][k][b][1] -> GetBinContent (p + 1);
	  n2 = yphi[a][k][b][0] -> GetBinContent (p + 1);
	  n3 = yphi[a][k][b][1] -> GetBinContent (p + 1 + phibins / 2);
	  n4 = yphi[a][k][b][0] -> GetBinContent (p + 1 + phibins / 2);
	  e1 = sqrt(n1);
	  e2 = sqrt(n2);
	  e3 = sqrt(n3);
	  e4 = sqrt(n4);
	  if ((n1 > 9) && (n2 > 9) && (n3 > 9) && (n4 > 9)) {
	    asym_val = square_asym  (n1, n2, n3, n4);
	    asym_err = square_error (n1, n2, n3, n4, e1, e2, e3, e4);
	    asymS[a][k][b] -> SetBinContent (p + 1, asym_val);
	    asymS[a][k][b] -> SetBinError   (p + 1, asym_err);
	  }
	}
	//polarization asymmetry
	for (int p = 0; p < phibins; p++) {
	  n1 = yphi[a][k][b][1] -> GetBinContent (p + 1);
	  n2 = yphi[a][k][b][0] -> GetBinContent (p + 1);
	  e1 = sqrt(n1);
	  e2 = sqrt(n2);
	  if ((n1 > 9) && (n2 > 9)) {
	    asymP[a][k][b] -> SetBinContent (p + 1, simple_asym  (n1, n2));
	    asymP[a][k][b] -> SetBinError   (p + 1, simple_error (n1, n2, e1, e2));
	  }
	}
	//simple left-right asymmetry
	for (int p = 0; p < phibins / 2; p++) {
	  n1 = yphi[a][k][b][0] -> GetBinContent (p + 1 + phibins / 2);
	  n2 = yphi[a][k][b][0] -> GetBinContent (p + 1);
	  n3 = yphi[a][k][b][1] -> GetBinContent (p + 1);
	  n4 = yphi[a][k][b][1] -> GetBinContent (p + 1 + phibins / 2);
	  e1 = sqrt(n1);
	  e2 = sqrt(n2);
	  e3 = sqrt(n3);
	  e4 = sqrt(n4);
	  if ((n1 > 9) && (n2 > 9) && (n3 > 9) && (n4 > 9)) {
	    asym_val_up = simple_asym(n1, n2);
	    asym_err_up = simple_error(n1, n2, e1, e2);
	    asym_val_down = simple_asym(n3, n4);
	    asym_err_down = simple_error(n3, n4, e3, e4);
	    asym_val = weighted_mean(asym_val_up, asym_val_down, asym_err_up, asym_err_down);
	    asym_err = weighted_error(asym_err_up, asym_err_down);
	    asymL[a][k][b] -> SetBinContent (p + 1, asym_val_up);
	    asymL[a][k][b] -> SetBinError   (p + 1, asym_err_down);
	  }
	}
      }
      ////////////////////////////////////////////////
      //this is new do the cos average first
      double cosval[cosbins]; //[cosbins]
      int cosavg_den = 0;
      double cosavg_num = 0;
      double cosavg = 0;
      printf ("The f correction factor variables for %s xf bin %d. \n", inArm, k);
      printf ("%5s : %9s : %5s : %11s : %11s \n", "phibin", "cosval[p]", "n1", "cosavg_num", "cosavg_den");
      for (int p = 0; p < cosbins; p++) {
	n1 = 0;
	n1 = yphi3[a][k] -> GetBinContent (p + 1);
	cosval[p] = PI/(cosbins/2) * double(p) - PI + (PI/(cosbins/2)/2);
	if (n1 > 0) {
	  cosavg_num += (n1 * fabs( cos( cosval[p] ) ) );
	  cosavg_den += n1;
	}
	printf ("%5d : %1.2f : %5d : %1.2f : %1.1f \n", p, cosval[p], n1, cosavg_num, cosavg_den);
      }
      cosavg = cosavg_num / double(cosavg_den);
      printf("The correction factor f for %s xf bin %d is %1.2f. \n", inArm, k, 1/cosavg);
      //end of cos avg function f
      
      /////////////////////////////////////////////////
      //this is new let's just do sqrt, left-right
      printf ("The sqrt-formula spin dependent yields for %s xf bin %d. \n", inArm, k);
      for (int b = 0; b < 2; b++) {     // blue-yellow
	n1 = n2 = n3 = n4 = 0;
	n1 = yphi2[a][k][b][1] -> GetBinContent (1);
	n2 = yphi2[a][k][b][1] -> GetBinContent (2);
	n3 = yphi2[a][k][b][0] -> GetBinContent (1);
	n4 = yphi2[a][k][b][0] -> GetBinContent (2);
	e1 = sqrt(n1);
	e2 = sqrt(n2);
	e3 = sqrt(n3);
	e4 = sqrt(n4);
	if ((n1 > 9) && (n2 > 9) && (n3 > 9) && (n4 > 9)) {
	  printf ("%5s : %5s : %5s : %5s : %5s : %5s : %5s : %5s : %5s \n", "beam", "n1", "n2", "n3", "n4", "e1", "e2", "e3", "e4");
	  printf ("%5d : %5d : %5d : %5d : %5d : %5d : %5d : %5d : %5d \n", b, n1, n2, n3, n4, e1, e2, e3, e4);
	  asym_val = (1/cosavg)*(square_asym  (n1, n2, n3, n4));
	  asym_err = (1/cosavg)*(square_error (n1, n2, n3, n4, e1, e2, e3, e4));
	  cout << "The sqrt-formula value of asym_val,asym_err after f correction for beam " << b << " is:  " << asym_val << ", " << asym_err << endl;
	  asymS2[a][k][b] -> SetBinContent (1, asym_val);
	  asymS2[a][k][b] -> SetBinError   (1, asym_err);
	}
      }
      //this is the end of the new sqrt asym part
      
      /////////////////////////////////////////////////
      //this is new let's just do pol up-down
      printf ("The relative luminosity spin dependent yields for %s xf bin %d. \n", inArm, k);
      for (int b = 0; b < 2; b++) {        // blue-yellow      
	n1 = n2 = n3 = n4 = 0;
	n1 = yphi2[a][k][b][1] -> GetBinContent (1);
	n2 = yphi2[a][k][b][1] -> GetBinContent (2);
	n3 = yphi2[a][k][b][0] -> GetBinContent (1);
	n4 = yphi2[a][k][b][0] -> GetBinContent (2);
	e1 = sqrt(n1);
	e2 = sqrt(n2);
	e3 = sqrt(n3);
	e4 = sqrt(n4);
 
	if ((n1 > 9) && (n2 > 9) && (n3 > 9) && (n4 > 9)) {
	  printf ("%5s : %5s : %5s : %5s : %5s : %5s : %5s : %5s : %5s : %5s : %11s : %11s \n", "phibin", "beam", "n1", "n2", "n3", "n4", "e1", "e2", "e3", "e4", "cosavg_num", "cosavg_den");
	  printf ("%5d : %5d : %5d : %5d : %5d : %5d : %5d : %5d : %5d : %5d : %1.2f : %1.1f \n", p, b, n1, n2, n3, n4, e1, e2, e3, e4, cosavg_num, cosavg_den);
	  asym_val_left = (1/cosavg)*(simple_asym  (n1, n3));
	  asym_err_left = (1/cosavg)*(simple_error (n1, n3, e1, e3));
	  asym_val_right = (1/cosavg)*(simple_asym  (n4, n2));
	  asym_err_right = (1/cosavg)*(simple_error (n4, n2, e4, e2));
	  asym_val = weighted_mean(asym_val_left,asym_val_right,asym_err_left,asym_err_right);
	  asym_err = weighted_error(asym_err_left,asym_err_right);
	  cout << "The rel-lum value of asym_val,asym_err after f correction for beam " << b << " is:  " << asym_val << ", " << asym_err << endl;
	  asymP2[a][k][b] -> SetBinContent (1, asym_val);
	  asymP2[a][k][b] -> SetBinError   (1, asym_err);
	}
      }
      //this is the end of the new pol asym part
      ////////////////////////////////////////////////
    
      // Determine the amplitude of the single spin asymmetries as function of xf !!!
      for (int b = 0; b < 2; b++) {
	printf ("==============================================\n");
	printf (" fit results for %s xf-bin %d, beam %d \n", inArm, k, b);
	printf ("----------------------------------------------\n");
	printf ("::: sqrt,pol-asymmetries, left-right ::: \n");
	amp_val = asymS2[a][k][b] -> GetBinContent(1);
	amp_err = asymS2[a][k][b] -> GetBinError(1);
	if(b == 0){
	  xf_an6[a] -> SetBinContent (10.5 + (binjump + k) * (2 * b - 1) * binswap, amp_val / bluePol);
	  xf_an6[a] -> SetBinError   (10.5 + (binjump + k) * (2 * b - 1) * binswap, amp_err / bluePol);
	}
	else{
	  xf_an6[a] -> SetBinContent (10.5 + (binjump + k) * (2 * b - 1) * binswap, amp_val / yellowPol);
	  xf_an6[a] -> SetBinError   (10.5 + (binjump + k) * (2 * b - 1) * binswap, amp_err / yellowPol);
	}
	amp_val = asymP2[a][k][b] -> GetBinContent(1);
	amp_err = asymP2[a][k][b] -> GetBinError(1);
	if(b == 0){
	  xf_an7[a] -> SetBinContent (10.5 + (binjump + k) * (2 * b - 1) * binswap, amp_val / bluePol);
	  xf_an7[a] -> SetBinError   (10.5 + (binjump + k) * (2 * b - 1) * binswap, amp_err / bluePol);
	}
	else{
	  xf_an7[a] -> SetBinContent (10.5 + (binjump + k) * (2 * b - 1) * binswap, amp_val / yellowPol);
	  xf_an7[a] -> SetBinError   (10.5 + (binjump + k) * (2 * b - 1) * binswap, amp_err / yellowPol);
	}
	
	printf ("----------------------------------------------\n");
	printf ("::: sqrt-asymmetries ::: \n");
	printf ("plain cosine fit: \n");
	fitcos -> SetParameters (0., 0.);
	asymS[a][k][b] -> Fit ("an_cos", "R");
	amp_val = fitcos -> GetParameter (0);
	amp_err = fitcos -> GetParError  (0);
	xf_asymfit1[a] -> SetBinContent (10.5 + (binjump + k) * (2 * b - 1) * binswap, amp_val);
	xf_asymfit1[a] -> SetBinError   (10.5 + (binjump + k) * (2 * b - 1) * binswap, amp_err);
	printf (" %5.3f +/- %5.3f \n", amp_val, amp_err);
	ndf     = fitcos -> GetNDF();
	csq     = fitcos -> GetChisquare();
	if (ndf > 1){
	  fit_rndf1[a] -> Fill (csq / (ndf - 1));
	}
	if(b == 0){
	  xf_an1[a] -> SetBinContent (10.5 + (binjump + k) * (2 * b - 1) * binswap, amp_val / bluePol);
	  xf_an1[a] -> SetBinError   (10.5 + (binjump + k) * (2 * b - 1) * binswap, amp_err / bluePol);
	}
	else{
	  xf_an1[a] -> SetBinContent (10.5 + (binjump + k) * (2 * b - 1) * binswap, amp_val / yellowPol);
	  xf_an1[a] -> SetBinError   (10.5 + (binjump + k) * (2 * b - 1) * binswap, amp_err / yellowPol);
	}
	printf ("sine fit with free phase: \n");
	fitsin -> SetParameters (0., 1.5 * PI);
	asymS[a][k][b] -> Fit ("an_sin", "R");
	amp_val = fitsin -> GetParameter (0);
	amp_err = fitsin -> GetParError  (0);
	phi_val = fitsin -> GetParameter (1);
	phi_err = fitsin -> GetParError  (1);
	// ========>  correlation of sign of amplitude and phi0 !!! <========
	if (sin (phi_val) < 0.) {phi_val += PI; amp_val *= -1.;}
	phi_val = phase_modulo (phi_val);
	xf_asymfit2[a] -> SetBinContent (10.5 + (binjump + k) * (2 * b - 1) * binswap, amp_val);
	xf_asymfit2[a] -> SetBinError   (10.5 + (binjump + k) * (2 * b - 1) * binswap, amp_err);
	xf_phi0fit2[a] -> SetBinContent (10.5 + (binjump + k) * (2 * b - 1) * binswap, phi_val - 0.5 * PI);
	xf_phi0fit2[a] -> SetBinError   (10.5 + (binjump + k) * (2 * b - 1) * binswap, phi_err);
	printf (" %5.3f +/- %5.3f \n", amp_val, amp_err);
	printf (" %5.3f +/- %5.3f \n", phi_val, phi_err);
	ndf     = fitsin -> GetNDF();
	csq     = fitsin -> GetChisquare();
	if (ndf > 1){
	  fit_rndf2[a] -> Fill (csq / (ndf - 1));
	}
	printf ("----------------------------------------------\n");
	printf ("::: pol-asymmetries :::");
	printf ("constant plus cosine fit: \n");
	fitcosP -> SetParameters (0., 0.);
	asymP[a][k][b] -> Fit ("an_cosP", "R");
	rel_val = fitcosP -> GetParameter (0);
	rel_err = fitcosP -> GetParError  (0);
	amp_val = fitcosP -> GetParameter (1);
	amp_err = fitcosP -> GetParError  (1);
	xf_rellfit3[a] -> SetBinContent (10.5 + (binjump + k) * (2 * b - 1) * binswap, rel_val);
	xf_rellfit3[a] -> SetBinError   (10.5 + (binjump + k) * (2 * b - 1) * binswap, rel_err);
	xf_asymfit3[a] -> SetBinContent (10.5 + (binjump + k) * (2 * b - 1) * binswap, amp_val);
	xf_asymfit3[a] -> SetBinError   (10.5 + (binjump + k) * (2 * b - 1) * binswap, amp_err);
	printf (" %5.3f +/- %5.3f \n", rel_val, rel_err);
	printf (" %5.3f +/- %5.3f \n", amp_val, amp_err);
	ndf     = fitcosP -> GetNDF();
	csq     = fitcosP -> GetChisquare();
	if (ndf > 1){
	  fit_rndf3[a] -> Fill (csq / (ndf - 1));
	}
	printf ("constant plus sine fit with free phase: \n");
	fitsinP -> SetParameters (0., 1.5 * PI);
	asymP[a][k][b] -> Fit ("an_sinP", "R");
	rel_val = fitsinP -> GetParameter (0);
	rel_err = fitsinP -> GetParError  (0);
	amp_val = fitsinP -> GetParameter (1);
	amp_err = fitsinP -> GetParError  (1);
	phi_val = fitsinP -> GetParameter (2);
	phi_err = fitsinP -> GetParError  (2);
	// ========>  correlation of sign of amplitude and phi0 !!! <========
	if (sin (phi_val) < 0.) {phi_val += PI; amp_val *= -1.;}
	phi_val = phase_modulo (phi_val);
	xf_rellfit4[a] -> SetBinContent (10.5 + (binjump + k) * (2 * b - 1) * binswap, rel_val);
	xf_rellfit4[a] -> SetBinError   (10.5 + (binjump + k) * (2 * b - 1) * binswap, rel_err);
	xf_asymfit4[a] -> SetBinContent (10.5 + (binjump + k) * (2 * b - 1) * binswap, amp_val);
	xf_asymfit4[a] -> SetBinError   (10.5 + (binjump + k) * (2 * b - 1) * binswap, amp_err);
	xf_phi0fit4[a] -> SetBinContent (10.5 + (binjump + k) * (2 * b - 1) * binswap, phi_val - 0.5 * PI);
	xf_phi0fit4[a] -> SetBinError   (10.5 + (binjump + k) * (2 * b - 1) * binswap, phi_err);
	printf (" %5.3f +/- %5.3f \n", rel_val, rel_err);
	printf (" %5.3f +/- %5.3f \n", amp_val, amp_err);
	printf (" %5.3f +/- %5.3f \n", phi_val, phi_err);
	ndf     = fitsinP -> GetNDF();
	csq     = fitsinP -> GetChisquare();
	if (ndf > 1){
	  fit_rndf4[a] -> Fill (csq / (ndf - 1));
	}
      }
    }// End of the slices in k !!!
    cout << "END OF SLICES IN XF BINS!" << endl;

    // Determine the global relative luminosity !!!
    TLine *RLine[2];
    Double_t avRL[2];
    Double_t erRL[2];
    TF1 *relBlue   = new TF1 ("relBlue",   "pol0", -.7, -.1);
    TF1 *relYellow = new TF1 ("relYellow", "pol0",  .1,  .7);
    xf_rellfit3[a] -> Fit ("relBlue",   "R");
    avRL[0] = relBlue   -> GetParameter (0);
    erRL[0] = relBlue   -> GetParError  (0);
    xf_rellfit3[a] -> Fit ("relYellow", "R");
    avRL[1] = relYellow -> GetParameter (0);
    erRL[1] = relYellow -> GetParError  (0);
    for (int b = 0; b < 2; b++)
      for (int k = 0; k < nbins; k++)
	for (int p = 0; p < phibins; p++)
	  if (asymP[a][k][b] -> GetBinError   (p + 1)){ 
	    asymF[a][k][b] -> SetBinContent (p + 1, asymP[a][k][b] -> GetBinContent (p + 1) - avRL[b]);
	    asymF[a][k][b] -> SetBinError   (p + 1, asymP[a][k][b] -> GetBinError   (p + 1));
	  }

    RLine[0] = new TLine (-.7, avRL[0], -.1, avRL[0]); RLine[0] -> SetLineWidth (3);
    RLine[1] = new TLine ( .1, avRL[1],  .7, avRL[1]); RLine[1] -> SetLineWidth (3);
  
    for (int b = 0; b < 2; b++)
      for (int k = 0; k < nbins; k++) {
	printf ("==============================================\n");
	printf ("::: final pol-asymmetries :::");
	printf ("constant plus cosine fit (global relative luminosity): \n");
	fitcosF -> SetParameters (0., 0.);
	asymF[a][k][b] -> Fit ("an_cosF", "R");
	amp_val = fitcosF -> GetParameter (0);
	amp_err = fitcosF -> GetParError  (0);
	xf_asymfit5[a] -> SetBinContent (10.5 + (binjump + k) * (2 * b - 1) * binswap, amp_val);
	xf_asymfit5[a] -> SetBinError   (10.5 + (binjump + k) * (2 * b - 1) * binswap, amp_err);
	printf (" %5.3f +/- %5.3f \n", rel_val, rel_err);
	printf (" %5.3f +/- %5.3f \n", amp_val, amp_err);
	ndf     = fitcosF -> GetNDF();
	csq     = fitcosF -> GetChisquare();
	if (ndf > 1){
	  fit_rndf5[a] -> Fill (csq / (ndf - 1));
	}
      
	if(b == 0){
	  xf_an5[a] -> SetBinContent (10.5 + (binjump + k) * (2 * b - 1) * binswap, amp_val / bluePol);
	  xf_an5[a] -> SetBinError   (10.5 + (binjump + k) * (2 * b - 1) * binswap, amp_err / bluePol);
	}
	else{
	  xf_an5[a] -> SetBinContent (10.5 + (binjump + k) * (2 * b - 1) * binswap, amp_val / yellowPol);
	  xf_an5[a] -> SetBinError   (10.5 + (binjump + k) * (2 * b - 1) * binswap, amp_err / yellowPol);
	}
      }

    // Images !!!
    /*   if(Peak == 0){
      xf_asymfit1[a] -> SetMinimum (-.08);
      xf_asymfit1[a] -> SetMaximum ( .13);
      xf_an1[a] -> SetMinimum (-.20);
      xf_an1[a] -> SetMaximum ( .25);
    }
    else if(Peak == 1 || Peak == 2){
      xf_asymfit1[a] -> SetMinimum (-.17);
      xf_asymfit1[a] -> SetMaximum ( .17);
      xf_an1[a] -> SetMinimum (-.35); 
      xf_an1[a] -> SetMaximum ( .25);
    }*/
    xf_an1[a] -> SetMinimum (-.20);
    xf_an1[a] -> SetMaximum ( .25);
    TLatex *Lpeak;
    if(Peak == 0){Lpeak = new TLatex(-0.7, 0.2, "#eta meson mass region");}
    else if(Peak == 1){Lpeak = new TLatex(-0.7, 0.2, "0.30 < M_{clcl} < 0.45 GeV/c^{2}");}
    else if(Peak == 2){Lpeak = new TLatex(-0.7, 0.2, "0.70 < M_{clcl} < 0.85 GeV/c^{2}");}
    else if(Peak == 3){Lpeak = new TLatex(-0.7, 0.2, "1.0 < M_{clcl} < 1.3 GeV/c^{2}");}

    TLegend *Legend1 = new TLegend (.15, .7, .5, .88);
    Legend1 -> SetFillStyle (0);
    Legend1 -> SetLineColor (0);
    Legend1 -> AddEntry (xf_asymfit1[a], "#epsilon_{sqrt}:a*cos(#varphi)");
    Legend1 -> AddEntry (xf_asymfit3[a], "#epsilon_{pol}:b+a*cos(#varphi)");
    Legend1 -> AddEntry (xf_asymfit5[a], "#epsilon_{pol}:#bar{b}+a*cos(#varphi)");
    
    TLine *zxf = new TLine (-1., 0., 1., 0.);
    if(Final == 0){
      char *asymxNameText = "./images_xf_rxy%d%d/asym2p_peak%d_trig%d_nbins%d_arm%d.gif";
      sprintf (Hname, asymxNameText, RMIN, RMAX, Peak, Trig, nbins, a);
    }else{
      char *asymxNameText = "./images_xf/asym2p_peak%d_trig%d_nbins%d_arm%d.gif";
      sprintf (Hname, asymxNameText, Peak, Trig, nbins, a);
    }

    TCanvas *Casymx = new TCanvas ("asym", "asym", 500, 500);
    //Casymx -> Divide (1, 2);
    //Casymx -> cd(1);
    //xf_asymfit1[a] -> Draw();
    //xf_asymfit3[a] -> Draw("SAME");
    //xf_asymfit5[a] -> Draw("SAME");
    //Legend1 -> Draw ("SAME");
    //zxf -> Draw();
    //Casymx -> cd(2);
    //xf_an5[a] -> Draw();
    xf_an1[a] -> Draw();
    Lpeak -> Draw();
    zxf -> Draw();

    Casymx -> Update();
    Casymx -> SaveAs (Hname);

    TLatex *Lxf[4][2];
    int neg = 0;
    int pos = 1;
    if(a == 1){neg = 1; pos = 0;}
    if(Trig == 0){
      if(nbins == 1){
	Lxf[0][neg] = new TLatex (-2.8, .08, " -0.3 < x_{F} < -0.2");
	Lxf[0][pos] = new TLatex (-2.8, .08, " 0.2 < x_{F} < 0.3");
      }
      else{
	Lxf[0][neg] = new TLatex (-2.8, .08, "-0.3 < x_{f} < -0.2");
	Lxf[1][neg] = new TLatex (-2.8, .08, "-0.4 < x_{f} < -0.3");
	Lxf[0][pos] = new TLatex (-2.8, .08, "0.2 < x_{f} < 0.3");
	Lxf[1][pos] = new TLatex (-2.8, .08, "0.3 < x_{f} < 0.4");
      }
    }
    if(Trig == 1){
      if(nbins == 1){
	Lxf[0][neg] = new TLatex (-2.8, .08, " -0.7 < x_{F} < -0.3");
	Lxf[0][pos] = new TLatex (-2.8, .08, " 0.3 < x_{F} < 0.7");
      }
      else{
	Lxf[0][neg] = new TLatex (-2.8, .08, "-0.4 < x_{F} < -0.3");
	Lxf[1][neg] = new TLatex (-2.8, .08, "-0.5 < x_{F} < -0.4");
	Lxf[2][neg] = new TLatex (-2.8, .08, "-0.6 < x_{F} < -0.5");
	Lxf[3][neg] = new TLatex (-2.8, .16, "-0.7 < x_{F} < -0.6");
	Lxf[0][pos] = new TLatex (-2.8, .08, "0.3 < x_{F} < 0.4");
	Lxf[1][pos] = new TLatex (-2.8, .08, "0.4 < x_{F} < 0.5");
	Lxf[2][pos] = new TLatex (-2.8, .08, "0.5 < x_{F} < 0.6");
	Lxf[3][pos] = new TLatex (-2.8, .16, "0.6 < x_{F} < 0.7");
      }
    }

    //    for (int k = 0; k < 3, k++){Lxf[k] -> SetTextSize (0.07);}
    TLine *phi_zero1 = new TLine (-PI, 0., 0., 0.);
    TLine *phi_zero2 = new TLine (-PI, 0., PI, 0.);
    cout<<"blah"<<endl;    
    TH1D *tasym1[2][nbins][2];
    TH1D *tasym2[2][nbins][2];
    TH1D *tasym3[2][nbins][2];
    TH1D *tasym4[2][nbins][2];
    TH1D *tasym5[2][nbins][2];
    cout<<"blah"<<endl;
    if(Final == 0){
      char *asymsNameText = "./images_xf_rxy%d%d/asym2s_peak%d_trig%d_nbins%d_arm%d.gif";
      sprintf (Hname, asymsNameText, RMIN, RMAX, Peak, Trig, nbins, a);
    }else{
      char *asymsNameText = "./images_xf/asym2s_peak%d_trig%d_nbins%d_arm%d.gif";
      sprintf (Hname, asymsNameText, Peak, Trig, nbins, a);
    }
    TCanvas *Casym4 = new TCanvas ("asyms", "asyms", 1200, 400*(nbins));
    Casym4 -> Divide (2, nbins);
    for (int k = 0; k < nbins; k++)
      for (int b = 0; b < 2; b++) {
	if(k < 3){
	  asymF[a][k][b] -> SetMinimum (-0.10);
	  asymF[a][k][b] -> SetMaximum (0.10);
	}else{
	  asymF[a][k][b] -> SetMinimum (-0.20);
	  asymF[a][k][b] -> SetMaximum (0.20); 
	}
	if(a == 0){
	  //Casym4 -> cd (4 * k + 2 * b + 2);
	  Casym4 -> cd (2 * k + b + 1);
	}else{
	  //Casym4 -> cd (4 * k - 2 * b + 4);
	  Casym4 -> cd (2 * k - b + 2);
	}
	tasym5[a][k][b] = (TH1D*)asymF[a][k][b]->Clone();
	tasym5[a][k][b] -> Fit ("an_cosF", "R");
	tasym5[a][k][b] -> Draw();
	Lxf[k][b] -> Draw("same");
	phi_zero2 -> Draw("same");
      }
    Casym4 -> SaveAs (Hname);
    cout<<"blah"<<endl;
    if(Final == 0){
      char *asymqNameText = "./images_xf_rxy%d%d/asym2q_peak%d_trig%d_nbins%d_arm%d.gif";
      sprintf (Hname, asymqNameText, RMIN, RMAX, Peak, Trig, nbins, a);
    }else{
      char *asymqNameText = "./images_xf/asym2q_peak%d_trig%d_nbins%d_arm%d.gif";
      sprintf (Hname, asymqNameText, Peak, Trig, nbins, a);
    }
    TCanvas *Casym5 = new TCanvas ("asymq", "asymq", 1200, 400*(nbins));
    Casym5 -> Divide (2, nbins);
    for (int k = 0; k < nbins; k++)
      for (int b = 0; b < 2; b++) {
	if(k < 3){
	  asymS[a][k][b] -> SetMinimum (-.10);
	  asymS[a][k][b] -> SetMaximum ( .10);     
	}else{
	  asymS[a][k][b] -> SetMinimum (-.20);
	  asymS[a][k][b] -> SetMaximum ( .20);     
	}
	if(a == 0){
	  //Casym4 -> cd (4 * k + 2 * b + 2);
	  Casym5 -> cd (2 * k + b + 1);
	}else{
	  //Casym4 -> cd (4 * k - 2 * b + 4);
	  Casym5 -> cd (2 * k - b + 2);
	}
	tasym1[a][k][b] = (TH1D*)asymS[a][k][b]->Clone();
	tasym1[a][k][b] -> Fit ("an_cos", "R");
	tasym1[a][k][b] -> Draw();
	Lxf[k][b] -> Draw("same");
	phi_zero1 -> Draw("same");
      }
    Casym5 -> SaveAs (Hname);

    TLine *defaultshiftblue   = new TLine (-1., PI, 1., PI);
    defaultshiftblue-> SetLineStyle (2);
    TLine *defaultshiftyellow = new TLine (-1., 0., 1., 0.);
    TLegend *Legend2 = new TLegend (.16, .65, .5, .88);
    //TLegend *Legend1 = new TLegend (.15, .7, .5, .88);
    Legend2 -> SetFillStyle (0);
    Legend2 -> SetLineColor (0);
    Legend2 -> AddEntry (xf_asymfit1[a], "#epsilon_{sqrt}:a*cos(#varphi)");
    Legend2 -> AddEntry (xf_asymfit2[a], "#epsilon_{sqrt}:a*cos(#varphi+#varphi_{0})");
    Legend2 -> AddEntry (xf_asymfit3[a], "#epsilon_{pol}:b+a*cos(#varphi)");
    Legend2 -> AddEntry (xf_asymfit4[a], "#epsilon_{pol}:b+a*cos(#varphi+#varphi_{0})");

    if(Final == 0){
      char *fitsNameText = "./images_xf_rxy%d%d/fitsummary_peak%d_trig%d_nbins%d_arm%d.gif";
      sprintf (Hname, fitsNameText, RMIN, RMAX, Peak, Trig, nbins, a);
    }else{
      char *fitsNameText = "./images_xf/fitsummary_peak%d_trig%d_nbins%d_arm%d.gif";
      sprintf (Hname, fitsNameText, Peak, Trig, nbins, a);
    }
    //printf("%s \n", Hname);
    TCanvas *Cfits = new TCanvas ("fitsummary", "fitsummary", 1000, 1000);
    Cfits -> Divide (2, 2);
    
   
    Cfits -> cd (1);
    xf_asymfit1[a] -> Draw();
    xf_asymfit2[a] -> Draw("same");
    xf_asymfit3[a] -> Draw("same");
    xf_asymfit4[a] -> Draw("same");
    Legend2 -> Draw ("same");
    zxf -> Draw();
   
    Cfits -> cd (3);
    xf_rellfit3[a] -> Draw();
    xf_rellfit4[a] -> Draw ("same");
    RLine[0] -> Draw();
    RLine[1] -> Draw();
       
    Cfits -> cd (4);
    xf_phi0fit4[a] -> Draw();
    defaultshiftblue -> Draw("same");
    defaultshiftyellow -> Draw("same");

    Cfits -> cd (2);
    xf_phi0fit2[a] -> Draw();
    defaultshiftblue   -> Draw("same");
    defaultshiftyellow -> Draw("same");  

    //Cfits -> cd();
    Cfits -> SaveAs (Hname);

    //End of Images!!!
    printf ("==================================================\n");
    printf ("Arm %s mean blue relative luminosity:   %5.3f +/- %5.3f \n", inArm, avRL[0], erRL[0]);
    printf ("Arm %s mean yellow relative luminosity: %5.3f +/- %5.3f \n", inArm, avRL[1], erRL[1]);
    printf ("==================================================\n\n");
    
  }  //End of Arms!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11

  //Let's get the average pt, xf
  for (int k = 0; k < nbins; k++) {
    //labels!
    float xfTitleMin, xfTitleMax;
    if(Trig == 0 || Trig == 2 || Trig == 3){
      xfTitleMin = 0.1 * float (k) + 0.2;
      xfTitleMax = 0.1 * float (k) + 0.3;
      if(NBins == 1){xfTitleMin = 0.2, xfTitleMax = 0.4;}
    }
    if( Trig == 1){
      xfTitleMin = 0.1 * float (k) + 0.3;
      xfTitleMax = 0.1 * float (k) + 0.4;
      if(NBins == 1){xfTitleMin = 0.4, xfTitleMax = 0.7;}
    }
    int kmin = xfTitleMin * 100 + 1;
    int kmax = xfTitleMax * 100 + 1;
    float meanxf;
    float rmsxf;
    float meanpt;
    float meaneta;
    for(int x = kmin; x < kmax; x++)
      for(int m = pi0_left; m <= pi0_right; m++){
	yxfmass3 -> SetBinContent(m, x, yxfmass -> GetBinContent(m, x));
	for(int p = 0; p < 500; p++){
	  yxfmasspt3 -> SetBinContent(m, x, p, yxfmasspt -> GetBinContent(m, x, p));
	}
	for(int p = 0; p < 300; p++){
	  yxfmasseta3 -> SetBinContent(m, x, p, yxfmasseta -> GetBinContent(m, x, p));
	}
      }     
    txf3 = yxfmass3 -> ProjectionY();
    meanxf = txf3 -> GetMean();
    txf3 -> Reset();
    yxfmass3 -> Reset();
    tpt3 = yxfmasspt3 -> ProjectionZ("tpt3");
    meanpt = tpt3 -> GetMean();
    tpt3 -> Reset();
    yxfmasspt3 -> Reset();
    c1 -> cd();
    yxfmasseta3 -> Draw();
    teta3 = yxfmasseta3 -> ProjectionZ("teta3");
    meaneta = teta3 -> GetMean();
    teta3 -> Reset();
    yxfmasseta3 -> Reset();
    cout << "k, meanxf, meanpt, meaneta " << k << " " << meanxf << " " << meanpt << " " << meaneta << endl;
    xf_mean -> SetBinContent(0.5 + (binjump + k) , meanxf);
    pt_mean -> SetBinContent(0.5 + (binjump + k) , meanpt);
    eta_mean -> SetBinContent(0.5 + (binjump + k) , meaneta);
    //exit(1);
  }

  //Let's get the average eta
  meaneta = yeta -> GetMean();
  cout << "The mean of pseudo-rapidity is " << meaneta << endl;

  //Write out to OutFile!!
  if(Final == 0){
    char *outNameText = "./results/asym2_peak%d_trig%d_nbins%d_rxy%d%d.root";
    sprintf (outName, outNameText, Peak, Trig, nbins, RMIN, RMAX);
  }else{
    char *outNameText = "./results/asym2_peak%d_trig%d_nbins%d.root";
    sprintf (outName, outNameText, Peak, Trig, nbins);
  }
  TFile *outFile = new TFile (outName, "RECREATE");
    
    //yxfmass -> Write();
    //yxfmasspt -> Write();
    //yxfmass3  -> Write();
    //yxfmasspt3  -> Write();
    xf_mean -> Write();
    pt_mean -> Write();
    eta_mean -> Write();
    yeta -> Write();

    for (int a = 0; a < 2; a++) {
      
      xf_asymfit1[a] -> Write();

      xf_asymfit2[a] -> Write();
      xf_phi0fit2[a] -> Write();

      xf_rellfit3[a] -> Write();
      xf_asymfit3[a] -> Write();

      xf_rellfit4[a] -> Write();
      xf_asymfit4[a] -> Write();
      xf_phi0fit4[a] -> Write();

      xf_asymfit5[a] -> Write();
 
      fit_rndf1[a] -> Write();
      fit_rndf2[a] -> Write();
      fit_rndf3[a] -> Write();
      fit_rndf4[a] -> Write();
      fit_rndf5[a] -> Write();

      xf_an5[a] -> Write();
      xf_an1[a] -> Write();
      xf_an3[a] -> Write();
      xf_an6[a] -> Write();
      xf_an7[a] -> Write();
      for (int k = 0; k < nbins; k++) {
	Yield3[a][k] -> Write();
	Yieldmix[a][k] -> Write();
	Yieldmix2[a][k] -> Write();
	Yieldmix3[a][k] -> Write();
	Hmass[a][k] -> Write();
	yphi3[a][k] -> Write();
	hphi_sub3[a][k] -> Write();
	hphi_raw3[a][k] -> Write();
	for (int i = 0; i < 2; i++)
	  for (int j = 0; j < 2; j++){
	    Yield[a][k][i][j] -> Write();
	    Yield2[a][k][i][j] -> Write();

	  
	    //hphi_raw[a][k][i][j] -> Write();
	    //hphi_raw2[a][k][i][j] -> Write();
	    hphi_sub[a][k][i][j] -> Write();
	    hphi_sub2[a][k][i][j] -> Write();

	  }
	for (int b = 0; b < 2; b++){    // blue-yellow
	  asymP[a][k][b] -> Write();
	  asymP2[a][k][b] -> Write();
	  asymS[a][k][b] -> Write();
	  asymS2[a][k][b] -> Write();
	  asymL[a][k][b] -> Write();
	  asymF[a][k][b] -> Write();

	  for (int d = 0; d < 2; d++) { // down-up
	    yphi[a][k][b][d] -> Write();
	    yphi2[a][k][b][d] -> Write();

	  }
	}
      }
    }
  /*
    for (int p = 0; p < phibins; p++)
    for (int i = 0; i < 2; i++)
    for (int j = 0; j < 2; j++){
    hmass[p][i][j] -> Write();
    hmass_ratio[p][i][j] -> Write();
    hmix_norm[p][i][j] -> Write();
    hmass_sub[p][i][j]  -> Write();
    hmass_final[p][i][j]  -> Write();
    }
    for (int p = 0; p < 2; p++)
    for (int i = 0; i < 2; i++)
    for (int j = 0; j < 2; j++){
    hmass2[p][i][j] -> Write();
    hmass_ratio2[p][i][j] -> Write();
    hmix_norm2[p][i][j] -> Write();
    hmass_sub2[p][i][j]  -> Write();
    hmass_final2[p][i][j] -> Write();
    }
    hmass3 -> Write();
    hmass_ratio3 -> Write();
    hmix_norm3 -> Write();
    hmass_sub3  -> Write();
    hmass_final3 -> Write();
    }
  */
  outFile -> Write();
  outFile -> Close();
}
